// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$0 from "../types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$1 from "../../borg/types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../../../../time/models.js";

/**
 * Actions that can be taken to resolve errors
 */
export enum ErrorAction {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorActionNone = "none",
    ErrorActionRegenerateSSH = "regenerateSSH",
    ErrorActionBreakLock = "breakLock",
};

/**
 * Error types for repository operations
 */
export enum ErrorType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorTypeSSHKey = "sshKey",
    ErrorTypePassphrase = "passphrase",
    ErrorTypeLocked = "locked",
};

/**
 * MountInfo contains mount information for archives
 */
export class MountInfo {
    "archiveId": number;
    "mountPath": string;

    /** Creates a new MountInfo instance. */
    constructor($$source: Partial<MountInfo> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MountInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): MountInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MountInfo($$parsedSource as Partial<MountInfo>);
    }
}

/**
 * MountType defines the type of mount
 */
export enum MountType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    MountTypeRepository = "repository",
    MountTypeArchive = "archive",
};

/**
 * Operation ADT definition
 */
export type Operation = any;

/**
 * RepositoryStateType is the discriminator enum for RepositoryState
 */
export enum RepositoryStateType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    RepositoryStateTypeBackingUp = "BackingUp",
    RepositoryStateTypeDeleting = "Deleting",
    RepositoryStateTypeError = "Error",
    RepositoryStateTypeIdle = "Idle",
    RepositoryStateTypeMounted = "Mounted",
    RepositoryStateTypePruning = "Pruning",
    RepositoryStateTypeQueued = "Queued",
    RepositoryStateTypeRefreshing = "Refreshing",
};

/**
 * RepositoryStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
 */
export class RepositoryStateUnion {
    /**
     * Discriminator field
     */
    "type": RepositoryStateType;

    /**
     * Variant fields - only one will be non-nil
     */
    "idle"?: StateIdle | null;
    "queued"?: StateQueued | null;
    "backingUp"?: StateBackingUp | null;
    "pruning"?: StatePruning | null;
    "deleting"?: StateDeleting | null;
    "refreshing"?: StateRefreshing | null;
    "mounted"?: StateMounted | null;
    "error"?: StateError | null;

    /** Creates a new RepositoryStateUnion instance. */
    constructor($$source: Partial<RepositoryStateUnion> = {}) {
        if (!("type" in $$source)) {
            this["type"] = RepositoryStateType.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RepositoryStateUnion instance from a string or object.
     */
    static createFrom($$source: any = {}): RepositoryStateUnion {
        const $$createField1_0 = $$createType1;
        const $$createField2_0 = $$createType3;
        const $$createField3_0 = $$createType5;
        const $$createField4_0 = $$createType7;
        const $$createField5_0 = $$createType9;
        const $$createField6_0 = $$createType11;
        const $$createField7_0 = $$createType13;
        const $$createField8_0 = $$createType15;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("idle" in $$parsedSource) {
            $$parsedSource["idle"] = $$createField1_0($$parsedSource["idle"]);
        }
        if ("queued" in $$parsedSource) {
            $$parsedSource["queued"] = $$createField2_0($$parsedSource["queued"]);
        }
        if ("backingUp" in $$parsedSource) {
            $$parsedSource["backingUp"] = $$createField3_0($$parsedSource["backingUp"]);
        }
        if ("pruning" in $$parsedSource) {
            $$parsedSource["pruning"] = $$createField4_0($$parsedSource["pruning"]);
        }
        if ("deleting" in $$parsedSource) {
            $$parsedSource["deleting"] = $$createField5_0($$parsedSource["deleting"]);
        }
        if ("refreshing" in $$parsedSource) {
            $$parsedSource["refreshing"] = $$createField6_0($$parsedSource["refreshing"]);
        }
        if ("mounted" in $$parsedSource) {
            $$parsedSource["mounted"] = $$createField7_0($$parsedSource["mounted"]);
        }
        if ("error" in $$parsedSource) {
            $$parsedSource["error"] = $$createField8_0($$parsedSource["error"]);
        }
        return new RepositoryStateUnion($$parsedSource as Partial<RepositoryStateUnion>);
    }
}

export class StateBackingUp {
    "backupId": types$0.BackupId;
    "progress"?: types$1.BackupProgress | null;
    "startedAt": time$0.Time;

    /** Creates a new StateBackingUp instance. */
    constructor($$source: Partial<StateBackingUp> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateBackingUp instance from a string or object.
     */
    static createFrom($$source: any = {}): StateBackingUp {
        const $$createField0_0 = $$createType16;
        const $$createField1_0 = $$createType18;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        if ("progress" in $$parsedSource) {
            $$parsedSource["progress"] = $$createField1_0($$parsedSource["progress"]);
        }
        return new StateBackingUp($$parsedSource as Partial<StateBackingUp>);
    }
}

export class StateDeleting {
    "archiveId": number;
    "startedAt": time$0.Time;

    /** Creates a new StateDeleting instance. */
    constructor($$source: Partial<StateDeleting> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateDeleting instance from a string or object.
     */
    static createFrom($$source: any = {}): StateDeleting {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new StateDeleting($$parsedSource as Partial<StateDeleting>);
    }
}

export class StateError {
    "errorType": ErrorType;
    "message": string;
    "action": ErrorAction;
    "occurredAt": time$0.Time;

    /** Creates a new StateError instance. */
    constructor($$source: Partial<StateError> = {}) {
        if (!("errorType" in $$source)) {
            this["errorType"] = ErrorType.$zero;
        }
        if (!("message" in $$source)) {
            this["message"] = "";
        }
        if (!("action" in $$source)) {
            this["action"] = ErrorAction.$zero;
        }
        if (!("occurredAt" in $$source)) {
            this["occurredAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateError instance from a string or object.
     */
    static createFrom($$source: any = {}): StateError {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new StateError($$parsedSource as Partial<StateError>);
    }
}

/**
 * State variant structs
 */
export class StateIdle {

    /** Creates a new StateIdle instance. */
    constructor($$source: Partial<StateIdle> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateIdle instance from a string or object.
     */
    static createFrom($$source: any = {}): StateIdle {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new StateIdle($$parsedSource as Partial<StateIdle>);
    }
}

export class StateMounted {
    "mountType": MountType;
    "archiveId"?: number | null;
    "mountPath": string;
    "archiveMounts": { [_: `${number}`]: MountInfo };

    /** Creates a new StateMounted instance. */
    constructor($$source: Partial<StateMounted> = {}) {
        if (!("mountType" in $$source)) {
            this["mountType"] = MountType.$zero;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }
        if (!("archiveMounts" in $$source)) {
            this["archiveMounts"] = {};
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateMounted instance from a string or object.
     */
    static createFrom($$source: any = {}): StateMounted {
        const $$createField3_0 = $$createType20;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("archiveMounts" in $$parsedSource) {
            $$parsedSource["archiveMounts"] = $$createField3_0($$parsedSource["archiveMounts"]);
        }
        return new StateMounted($$parsedSource as Partial<StateMounted>);
    }
}

export class StatePruning {
    "backupId": types$0.BackupId;
    "startedAt": time$0.Time;

    /** Creates a new StatePruning instance. */
    constructor($$source: Partial<StatePruning> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StatePruning instance from a string or object.
     */
    static createFrom($$source: any = {}): StatePruning {
        const $$createField0_0 = $$createType16;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        return new StatePruning($$parsedSource as Partial<StatePruning>);
    }
}

export class StateQueued {
    "nextOperation": Operation;
    "queueLength": number;

    /** Creates a new StateQueued instance. */
    constructor($$source: Partial<StateQueued> = {}) {
        if (!("nextOperation" in $$source)) {
            this["nextOperation"] = null;
        }
        if (!("queueLength" in $$source)) {
            this["queueLength"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateQueued instance from a string or object.
     */
    static createFrom($$source: any = {}): StateQueued {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new StateQueued($$parsedSource as Partial<StateQueued>);
    }
}

export class StateRefreshing {
    "startedAt": time$0.Time;

    /** Creates a new StateRefreshing instance. */
    constructor($$source: Partial<StateRefreshing> = {}) {
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new StateRefreshing instance from a string or object.
     */
    static createFrom($$source: any = {}): StateRefreshing {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new StateRefreshing($$parsedSource as Partial<StateRefreshing>);
    }
}

// Private type creation functions
const $$createType0 = StateIdle.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
const $$createType2 = StateQueued.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = StateBackingUp.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
const $$createType6 = StatePruning.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = StateDeleting.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
const $$createType10 = StateRefreshing.createFrom;
const $$createType11 = $Create.Nullable($$createType10);
const $$createType12 = StateMounted.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = StateError.createFrom;
const $$createType15 = $Create.Nullable($$createType14);
const $$createType16 = types$0.BackupId.createFrom;
const $$createType17 = types$1.BackupProgress.createFrom;
const $$createType18 = $Create.Nullable($$createType17);
const $$createType19 = MountInfo.createFrom;
const $$createType20 = $Create.Map($Create.Any, $$createType19);
