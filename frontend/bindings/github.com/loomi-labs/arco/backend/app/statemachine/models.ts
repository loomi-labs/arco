// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$1 from "../types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$0 from "../../borg/types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../../../../time/models.js";

export class BackingUp {
    "Data": Backup;

    /** Creates a new BackingUp instance. */
    constructor($$source: Partial<BackingUp> = {}) {
        if (!("Data" in $$source)) {
            this["Data"] = (new Backup());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new BackingUp instance from a string or object.
     */
    static createFrom($$source: any = {}): BackingUp {
        const $$createField0_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Data" in $$parsedSource) {
            $$parsedSource["Data"] = $$createField0_0($$parsedSource["Data"]);
        }
        return new BackingUp($$parsedSource as Partial<BackingUp>);
    }
}

export class Backup {
    "backupId": types$1.BackupId;
    "progress"?: types$0.BackupProgress | null;

    /** Creates a new Backup instance. */
    constructor($$source: Partial<Backup> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$1.BackupId());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Backup instance from a string or object.
     */
    static createFrom($$source: any = {}): Backup {
        const $$createField0_0 = $$createType1;
        const $$createField1_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        if ("progress" in $$parsedSource) {
            $$parsedSource["progress"] = $$createField1_0($$parsedSource["progress"]);
        }
        return new Backup($$parsedSource as Partial<Backup>);
    }
}

export class Deleting {
    "archiveId": number;
    "startedAt": time$0.Time;

    /** Creates a new Deleting instance. */
    constructor($$source: Partial<Deleting> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Deleting instance from a string or object.
     */
    static createFrom($$source: any = {}): Deleting {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Deleting($$parsedSource as Partial<Deleting>);
    }
}

export class Error {
    "errorType": ErrorType;
    "message": string;
    "action": ErrorAction;
    "occurredAt": time$0.Time;

    /** Creates a new Error instance. */
    constructor($$source: Partial<Error> = {}) {
        if (!("errorType" in $$source)) {
            this["errorType"] = ErrorType.$zero;
        }
        if (!("message" in $$source)) {
            this["message"] = "";
        }
        if (!("action" in $$source)) {
            this["action"] = ErrorAction.$zero;
        }
        if (!("occurredAt" in $$source)) {
            this["occurredAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Error instance from a string or object.
     */
    static createFrom($$source: any = {}): Error {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Error($$parsedSource as Partial<Error>);
    }
}

/**
 * Actions that can be taken to resolve errors
 */
export enum ErrorAction {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorActionNone = "none",
    ErrorActionRegenerateSSH = "regenerateSSH",
    ErrorActionBreakLock = "breakLock",
};

/**
 * Error types for repository operations
 */
export enum ErrorType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorTypeSSHKey = "sshKey",
    ErrorTypePassphrase = "passphrase",
    ErrorTypeLocked = "locked",
};

/**
 * State variant structs
 */
export class Idle {

    /** Creates a new Idle instance. */
    constructor($$source: Partial<Idle> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Idle instance from a string or object.
     */
    static createFrom($$source: any = {}): Idle {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Idle($$parsedSource as Partial<Idle>);
    }
}

/**
 * MountInfo contains mount information for archives and repositories
 */
export class MountInfo {
    "mountType": MountType;
    "archiveId"?: number | null;
    "mountPath": string;

    /** Creates a new MountInfo instance. */
    constructor($$source: Partial<MountInfo> = {}) {
        if (!("mountType" in $$source)) {
            this["mountType"] = MountType.$zero;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MountInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): MountInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MountInfo($$parsedSource as Partial<MountInfo>);
    }
}

/**
 * MountType defines the type of mount
 */
export enum MountType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    MountTypeRepository = "repository",
    MountTypeArchive = "archive",
};

export class Mounted {
    "mounts": MountInfo[];

    /** Creates a new Mounted instance. */
    constructor($$source: Partial<Mounted> = {}) {
        if (!("mounts" in $$source)) {
            this["mounts"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Mounted instance from a string or object.
     */
    static createFrom($$source: any = {}): Mounted {
        const $$createField0_0 = $$createType5;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("mounts" in $$parsedSource) {
            $$parsedSource["mounts"] = $$createField0_0($$parsedSource["mounts"]);
        }
        return new Mounted($$parsedSource as Partial<Mounted>);
    }
}

/**
 * Operation ADT definition
 */
export type Operation = any;

export class Pruning {
    "startedAt": time$0.Time;

    /** Creates a new Pruning instance. */
    constructor($$source: Partial<Pruning> = {}) {
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Pruning instance from a string or object.
     */
    static createFrom($$source: any = {}): Pruning {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Pruning($$parsedSource as Partial<Pruning>);
    }
}

export class Queued {
    "nextOperation": Operation;
    "queueLength": number;

    /** Creates a new Queued instance. */
    constructor($$source: Partial<Queued> = {}) {
        if (!("nextOperation" in $$source)) {
            this["nextOperation"] = null;
        }
        if (!("queueLength" in $$source)) {
            this["queueLength"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Queued instance from a string or object.
     */
    static createFrom($$source: any = {}): Queued {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Queued($$parsedSource as Partial<Queued>);
    }
}

export class Refreshing {
    "startedAt": time$0.Time;

    /** Creates a new Refreshing instance. */
    constructor($$source: Partial<Refreshing> = {}) {
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Refreshing instance from a string or object.
     */
    static createFrom($$source: any = {}): Refreshing {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Refreshing($$parsedSource as Partial<Refreshing>);
    }
}

/**
 * RepositoryState ADT definition
 */
export type RepositoryState = any;

/**
 * RepositoryStateType is the discriminator enum for RepositoryState
 */
export enum RepositoryStateType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    RepositoryStateTypeBackingUp = "BackingUp",
    RepositoryStateTypeDeleting = "Deleting",
    RepositoryStateTypeError = "Error",
    RepositoryStateTypeIdle = "Idle",
    RepositoryStateTypeMounted = "Mounted",
    RepositoryStateTypePruning = "Pruning",
    RepositoryStateTypeQueued = "Queued",
    RepositoryStateTypeRefreshing = "Refreshing",
};

/**
 * RepositoryStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
 */
export class RepositoryStateUnion {
    /**
     * Discriminator field
     */
    "type": RepositoryStateType;

    /**
     * Variant fields - only one will be non-nil
     */
    "idle"?: Idle | null;
    "queued"?: Queued | null;
    "backingUp"?: BackingUp | null;
    "pruning"?: Pruning | null;
    "deleting"?: Deleting | null;
    "refreshing"?: Refreshing | null;
    "mounted"?: Mounted | null;
    "error"?: Error | null;

    /** Creates a new RepositoryStateUnion instance. */
    constructor($$source: Partial<RepositoryStateUnion> = {}) {
        if (!("type" in $$source)) {
            this["type"] = RepositoryStateType.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RepositoryStateUnion instance from a string or object.
     */
    static createFrom($$source: any = {}): RepositoryStateUnion {
        const $$createField1_0 = $$createType7;
        const $$createField2_0 = $$createType9;
        const $$createField3_0 = $$createType11;
        const $$createField4_0 = $$createType13;
        const $$createField5_0 = $$createType15;
        const $$createField6_0 = $$createType17;
        const $$createField7_0 = $$createType19;
        const $$createField8_0 = $$createType21;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("idle" in $$parsedSource) {
            $$parsedSource["idle"] = $$createField1_0($$parsedSource["idle"]);
        }
        if ("queued" in $$parsedSource) {
            $$parsedSource["queued"] = $$createField2_0($$parsedSource["queued"]);
        }
        if ("backingUp" in $$parsedSource) {
            $$parsedSource["backingUp"] = $$createField3_0($$parsedSource["backingUp"]);
        }
        if ("pruning" in $$parsedSource) {
            $$parsedSource["pruning"] = $$createField4_0($$parsedSource["pruning"]);
        }
        if ("deleting" in $$parsedSource) {
            $$parsedSource["deleting"] = $$createField5_0($$parsedSource["deleting"]);
        }
        if ("refreshing" in $$parsedSource) {
            $$parsedSource["refreshing"] = $$createField6_0($$parsedSource["refreshing"]);
        }
        if ("mounted" in $$parsedSource) {
            $$parsedSource["mounted"] = $$createField7_0($$parsedSource["mounted"]);
        }
        if ("error" in $$parsedSource) {
            $$parsedSource["error"] = $$createField8_0($$parsedSource["error"]);
        }
        return new RepositoryStateUnion($$parsedSource as Partial<RepositoryStateUnion>);
    }
}

// Private type creation functions
const $$createType0 = Backup.createFrom;
const $$createType1 = types$1.BackupId.createFrom;
const $$createType2 = types$0.BackupProgress.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = MountInfo.createFrom;
const $$createType5 = $Create.Array($$createType4);
const $$createType6 = Idle.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = Queued.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
const $$createType10 = BackingUp.createFrom;
const $$createType11 = $Create.Nullable($$createType10);
const $$createType12 = Pruning.createFrom;
const $$createType13 = $Create.Nullable($$createType12);
const $$createType14 = Deleting.createFrom;
const $$createType15 = $Create.Nullable($$createType14);
const $$createType16 = Refreshing.createFrom;
const $$createType17 = $Create.Nullable($$createType16);
const $$createType18 = Mounted.createFrom;
const $$createType19 = $Create.Nullable($$createType18);
const $$createType20 = Error.createFrom;
const $$createType21 = $Create.Nullable($$createType20);
