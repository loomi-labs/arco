// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$0 from "../types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$1 from "../../borg/types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as ent$0 from "../../ent/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../../../../time/models.js";

export class ArchiveComment {
    "archiveId": number;
    "comment": string;

    /** Creates a new ArchiveComment instance. */
    constructor($$source: Partial<ArchiveComment> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("comment" in $$source)) {
            this["comment"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ArchiveComment instance from a string or object.
     */
    static createFrom($$source: any = {}): ArchiveComment {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ArchiveComment($$parsedSource as Partial<ArchiveComment>);
    }
}

export class ArchiveDelete {
    "archiveId": number;

    /** Creates a new ArchiveDelete instance. */
    constructor($$source: Partial<ArchiveDelete> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ArchiveDelete instance from a string or object.
     */
    static createFrom($$source: any = {}): ArchiveDelete {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ArchiveDelete($$parsedSource as Partial<ArchiveDelete>);
    }
}

export class ArchiveRefresh {
    "repositoryId": number;

    /** Creates a new ArchiveRefresh instance. */
    constructor($$source: Partial<ArchiveRefresh> = {}) {
        if (!("repositoryId" in $$source)) {
            this["repositoryId"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ArchiveRefresh instance from a string or object.
     */
    static createFrom($$source: any = {}): ArchiveRefresh {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ArchiveRefresh($$parsedSource as Partial<ArchiveRefresh>);
    }
}

export class ArchiveRename {
    "archiveId": number;
    "prefix": string;
    "name": string;

    /** Creates a new ArchiveRename instance. */
    constructor($$source: Partial<ArchiveRename> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("prefix" in $$source)) {
            this["prefix"] = "";
        }
        if (!("name" in $$source)) {
            this["name"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ArchiveRename instance from a string or object.
     */
    static createFrom($$source: any = {}): ArchiveRename {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ArchiveRename($$parsedSource as Partial<ArchiveRename>);
    }
}

export class BackingUp {
    "Data": Backup;

    /** Creates a new BackingUp instance. */
    constructor($$source: Partial<BackingUp> = {}) {
        if (!("Data" in $$source)) {
            this["Data"] = (new Backup());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new BackingUp instance from a string or object.
     */
    static createFrom($$source: any = {}): BackingUp {
        const $$createField0_0 = $$createType0;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Data" in $$parsedSource) {
            $$parsedSource["Data"] = $$createField0_0($$parsedSource["Data"]);
        }
        return new BackingUp($$parsedSource as Partial<BackingUp>);
    }
}

export class Backup {
    "backupId": types$0.BackupId;
    "progress"?: types$1.BackupProgress | null;

    /** Creates a new Backup instance. */
    constructor($$source: Partial<Backup> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Backup instance from a string or object.
     */
    static createFrom($$source: any = {}): Backup {
        const $$createField0_0 = $$createType1;
        const $$createField1_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        if ("progress" in $$parsedSource) {
            $$parsedSource["progress"] = $$createField1_0($$parsedSource["progress"]);
        }
        return new Backup($$parsedSource as Partial<Backup>);
    }
}

export class Check {
    "repositoryId": number;
    "quickVerification": boolean;

    /** Creates a new Check instance. */
    constructor($$source: Partial<Check> = {}) {
        if (!("repositoryId" in $$source)) {
            this["repositoryId"] = 0;
        }
        if (!("quickVerification" in $$source)) {
            this["quickVerification"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Check instance from a string or object.
     */
    static createFrom($$source: any = {}): Check {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Check($$parsedSource as Partial<Check>);
    }
}

export class Checking {
    "startedAt": time$0.Time;

    /** Creates a new Checking instance. */
    constructor($$source: Partial<Checking> = {}) {
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Checking instance from a string or object.
     */
    static createFrom($$source: any = {}): Checking {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Checking($$parsedSource as Partial<Checking>);
    }
}

export class Delete {
    "repositoryId": number;

    /** Creates a new Delete instance. */
    constructor($$source: Partial<Delete> = {}) {
        if (!("repositoryId" in $$source)) {
            this["repositoryId"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Delete instance from a string or object.
     */
    static createFrom($$source: any = {}): Delete {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Delete($$parsedSource as Partial<Delete>);
    }
}

export class Deleting {
    "archiveId": number;
    "startedAt": time$0.Time;

    /** Creates a new Deleting instance. */
    constructor($$source: Partial<Deleting> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Deleting instance from a string or object.
     */
    static createFrom($$source: any = {}): Deleting {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Deleting($$parsedSource as Partial<Deleting>);
    }
}

export class Error {
    "errorType": ErrorType;
    "message": string;
    "action": ErrorAction;
    "occurredAt": time$0.Time;

    /** Creates a new Error instance. */
    constructor($$source: Partial<Error> = {}) {
        if (!("errorType" in $$source)) {
            this["errorType"] = ErrorType.$zero;
        }
        if (!("message" in $$source)) {
            this["message"] = "";
        }
        if (!("action" in $$source)) {
            this["action"] = ErrorAction.$zero;
        }
        if (!("occurredAt" in $$source)) {
            this["occurredAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Error instance from a string or object.
     */
    static createFrom($$source: any = {}): Error {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Error($$parsedSource as Partial<Error>);
    }
}

/**
 * Actions that can be taken to resolve errors
 */
export enum ErrorAction {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorActionNone = "none",
    ErrorActionRegenerateSSH = "regenerateSSH",
    ErrorActionChangePassphrase = "changePassphrase",
    ErrorActionBreakLock = "breakLock",
};

/**
 * Error types for repository operations
 */
export enum ErrorType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    ErrorTypeGeneral = "general",
    ErrorTypeSSHKey = "sshKey",
    ErrorTypePassphrase = "passphrase",
    ErrorTypeLocked = "locked",
};

export class ExaminePrune {
    "backupId": types$0.BackupId;
    "pruningRule": ent$0.PruningRule | null;
    "saveResults": boolean;

    /** Creates a new ExaminePrune instance. */
    constructor($$source: Partial<ExaminePrune> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }
        if (!("pruningRule" in $$source)) {
            this["pruningRule"] = null;
        }
        if (!("saveResults" in $$source)) {
            this["saveResults"] = false;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ExaminePrune instance from a string or object.
     */
    static createFrom($$source: any = {}): ExaminePrune {
        const $$createField0_0 = $$createType1;
        const $$createField1_0 = $$createType5;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        if ("pruningRule" in $$parsedSource) {
            $$parsedSource["pruningRule"] = $$createField1_0($$parsedSource["pruningRule"]);
        }
        return new ExaminePrune($$parsedSource as Partial<ExaminePrune>);
    }
}

/**
 * State variant structs
 */
export class Idle {

    /** Creates a new Idle instance. */
    constructor($$source: Partial<Idle> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Idle instance from a string or object.
     */
    static createFrom($$source: any = {}): Idle {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Idle($$parsedSource as Partial<Idle>);
    }
}

export class Mount {
    "repositoryId": number;
    "mountPath": string;

    /** Creates a new Mount instance. */
    constructor($$source: Partial<Mount> = {}) {
        if (!("repositoryId" in $$source)) {
            this["repositoryId"] = 0;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Mount instance from a string or object.
     */
    static createFrom($$source: any = {}): Mount {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Mount($$parsedSource as Partial<Mount>);
    }
}

export class MountArchive {
    "archiveId": number;
    "mountPath": string;

    /** Creates a new MountArchive instance. */
    constructor($$source: Partial<MountArchive> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MountArchive instance from a string or object.
     */
    static createFrom($$source: any = {}): MountArchive {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MountArchive($$parsedSource as Partial<MountArchive>);
    }
}

/**
 * MountInfo contains mount information for archives and repositories
 */
export class MountInfo {
    "mountType": MountType;
    "archiveId"?: number | null;
    "mountPath": string;

    /** Creates a new MountInfo instance. */
    constructor($$source: Partial<MountInfo> = {}) {
        if (!("mountType" in $$source)) {
            this["mountType"] = MountType.$zero;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new MountInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): MountInfo {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new MountInfo($$parsedSource as Partial<MountInfo>);
    }
}

/**
 * MountType defines the type of mount
 */
export enum MountType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    MountTypeRepository = "repository",
    MountTypeArchive = "archive",
};

export class Mounted {
    "mounts": MountInfo[];

    /** Creates a new Mounted instance. */
    constructor($$source: Partial<Mounted> = {}) {
        if (!("mounts" in $$source)) {
            this["mounts"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Mounted instance from a string or object.
     */
    static createFrom($$source: any = {}): Mounted {
        const $$createField0_0 = $$createType7;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("mounts" in $$parsedSource) {
            $$parsedSource["mounts"] = $$createField0_0($$parsedSource["mounts"]);
        }
        return new Mounted($$parsedSource as Partial<Mounted>);
    }
}

export class Mounting {
    "mountType": MountType;
    "archiveId"?: number | null;

    /** Creates a new Mounting instance. */
    constructor($$source: Partial<Mounting> = {}) {
        if (!("mountType" in $$source)) {
            this["mountType"] = MountType.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Mounting instance from a string or object.
     */
    static createFrom($$source: any = {}): Mounting {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Mounting($$parsedSource as Partial<Mounting>);
    }
}

/**
 * OperationType is the discriminator enum for Operation
 */
export enum OperationType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    OperationTypeArchiveComment = "ArchiveComment",
    OperationTypeArchiveDelete = "ArchiveDelete",
    OperationTypeArchiveRefresh = "ArchiveRefresh",
    OperationTypeArchiveRename = "ArchiveRename",
    OperationTypeBackup = "Backup",
    OperationTypeCheck = "Check",
    OperationTypeDelete = "Delete",
    OperationTypeExaminePrune = "ExaminePrune",
    OperationTypeMount = "Mount",
    OperationTypeMountArchive = "MountArchive",
    OperationTypePrune = "Prune",
    OperationTypeUnmount = "Unmount",
    OperationTypeUnmountArchive = "UnmountArchive",
};

/**
 * OperationUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
 */
export class OperationUnion {
    /**
     * Discriminator field
     */
    "type": OperationType;

    /**
     * Variant fields - only one will be non-nil
     */
    "backup"?: Backup | null;
    "prune"?: Prune | null;
    "delete"?: Delete | null;
    "archiveRefresh"?: ArchiveRefresh | null;
    "archiveDelete"?: ArchiveDelete | null;
    "archiveRename"?: ArchiveRename | null;
    "archiveComment"?: ArchiveComment | null;
    "mount"?: Mount | null;
    "mountArchive"?: MountArchive | null;
    "unmount"?: Unmount | null;
    "unmountArchive"?: UnmountArchive | null;
    "examinePrune"?: ExaminePrune | null;
    "check"?: Check | null;

    /** Creates a new OperationUnion instance. */
    constructor($$source: Partial<OperationUnion> = {}) {
        if (!("type" in $$source)) {
            this["type"] = OperationType.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new OperationUnion instance from a string or object.
     */
    static createFrom($$source: any = {}): OperationUnion {
        const $$createField1_0 = $$createType8;
        const $$createField2_0 = $$createType10;
        const $$createField3_0 = $$createType12;
        const $$createField4_0 = $$createType14;
        const $$createField5_0 = $$createType16;
        const $$createField6_0 = $$createType18;
        const $$createField7_0 = $$createType20;
        const $$createField8_0 = $$createType22;
        const $$createField9_0 = $$createType24;
        const $$createField10_0 = $$createType26;
        const $$createField11_0 = $$createType28;
        const $$createField12_0 = $$createType30;
        const $$createField13_0 = $$createType32;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backup" in $$parsedSource) {
            $$parsedSource["backup"] = $$createField1_0($$parsedSource["backup"]);
        }
        if ("prune" in $$parsedSource) {
            $$parsedSource["prune"] = $$createField2_0($$parsedSource["prune"]);
        }
        if ("delete" in $$parsedSource) {
            $$parsedSource["delete"] = $$createField3_0($$parsedSource["delete"]);
        }
        if ("archiveRefresh" in $$parsedSource) {
            $$parsedSource["archiveRefresh"] = $$createField4_0($$parsedSource["archiveRefresh"]);
        }
        if ("archiveDelete" in $$parsedSource) {
            $$parsedSource["archiveDelete"] = $$createField5_0($$parsedSource["archiveDelete"]);
        }
        if ("archiveRename" in $$parsedSource) {
            $$parsedSource["archiveRename"] = $$createField6_0($$parsedSource["archiveRename"]);
        }
        if ("archiveComment" in $$parsedSource) {
            $$parsedSource["archiveComment"] = $$createField7_0($$parsedSource["archiveComment"]);
        }
        if ("mount" in $$parsedSource) {
            $$parsedSource["mount"] = $$createField8_0($$parsedSource["mount"]);
        }
        if ("mountArchive" in $$parsedSource) {
            $$parsedSource["mountArchive"] = $$createField9_0($$parsedSource["mountArchive"]);
        }
        if ("unmount" in $$parsedSource) {
            $$parsedSource["unmount"] = $$createField10_0($$parsedSource["unmount"]);
        }
        if ("unmountArchive" in $$parsedSource) {
            $$parsedSource["unmountArchive"] = $$createField11_0($$parsedSource["unmountArchive"]);
        }
        if ("examinePrune" in $$parsedSource) {
            $$parsedSource["examinePrune"] = $$createField12_0($$parsedSource["examinePrune"]);
        }
        if ("check" in $$parsedSource) {
            $$parsedSource["check"] = $$createField13_0($$parsedSource["check"]);
        }
        return new OperationUnion($$parsedSource as Partial<OperationUnion>);
    }
}

export class Prune {
    "backupId": types$0.BackupId;

    /** Creates a new Prune instance. */
    constructor($$source: Partial<Prune> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Prune instance from a string or object.
     */
    static createFrom($$source: any = {}): Prune {
        const $$createField0_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        return new Prune($$parsedSource as Partial<Prune>);
    }
}

export class Pruning {
    "backupId": types$0.BackupId;

    /** Creates a new Pruning instance. */
    constructor($$source: Partial<Pruning> = {}) {
        if (!("backupId" in $$source)) {
            this["backupId"] = (new types$0.BackupId());
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Pruning instance from a string or object.
     */
    static createFrom($$source: any = {}): Pruning {
        const $$createField0_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("backupId" in $$parsedSource) {
            $$parsedSource["backupId"] = $$createField0_0($$parsedSource["backupId"]);
        }
        return new Pruning($$parsedSource as Partial<Pruning>);
    }
}

export class Queued {
    "nextOperation": OperationUnion;
    "queueLength": number;

    /** Creates a new Queued instance. */
    constructor($$source: Partial<Queued> = {}) {
        if (!("nextOperation" in $$source)) {
            this["nextOperation"] = (new OperationUnion());
        }
        if (!("queueLength" in $$source)) {
            this["queueLength"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Queued instance from a string or object.
     */
    static createFrom($$source: any = {}): Queued {
        const $$createField0_0 = $$createType33;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("nextOperation" in $$parsedSource) {
            $$parsedSource["nextOperation"] = $$createField0_0($$parsedSource["nextOperation"]);
        }
        return new Queued($$parsedSource as Partial<Queued>);
    }
}

export class Refreshing {
    "startedAt": time$0.Time;

    /** Creates a new Refreshing instance. */
    constructor($$source: Partial<Refreshing> = {}) {
        if (!("startedAt" in $$source)) {
            this["startedAt"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Refreshing instance from a string or object.
     */
    static createFrom($$source: any = {}): Refreshing {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Refreshing($$parsedSource as Partial<Refreshing>);
    }
}

/**
 * RepositoryStateType is the discriminator enum for RepositoryState
 */
export enum RepositoryStateType {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = "",

    RepositoryStateTypeBackingUp = "BackingUp",
    RepositoryStateTypeChecking = "Checking",
    RepositoryStateTypeDeleting = "Deleting",
    RepositoryStateTypeError = "Error",
    RepositoryStateTypeIdle = "Idle",
    RepositoryStateTypeMounted = "Mounted",
    RepositoryStateTypeMounting = "Mounting",
    RepositoryStateTypePruning = "Pruning",
    RepositoryStateTypeQueued = "Queued",
    RepositoryStateTypeRefreshing = "Refreshing",
};

/**
 * RepositoryStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
 */
export class RepositoryStateUnion {
    /**
     * Discriminator field
     */
    "type": RepositoryStateType;

    /**
     * Variant fields - only one will be non-nil
     */
    "idle"?: Idle | null;
    "queued"?: Queued | null;
    "backingUp"?: BackingUp | null;
    "pruning"?: Pruning | null;
    "deleting"?: Deleting | null;
    "refreshing"?: Refreshing | null;
    "checking"?: Checking | null;
    "mounting"?: Mounting | null;
    "mounted"?: Mounted | null;
    "error"?: Error | null;

    /** Creates a new RepositoryStateUnion instance. */
    constructor($$source: Partial<RepositoryStateUnion> = {}) {
        if (!("type" in $$source)) {
            this["type"] = RepositoryStateType.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new RepositoryStateUnion instance from a string or object.
     */
    static createFrom($$source: any = {}): RepositoryStateUnion {
        const $$createField1_0 = $$createType35;
        const $$createField2_0 = $$createType37;
        const $$createField3_0 = $$createType39;
        const $$createField4_0 = $$createType41;
        const $$createField5_0 = $$createType43;
        const $$createField6_0 = $$createType45;
        const $$createField7_0 = $$createType47;
        const $$createField8_0 = $$createType49;
        const $$createField9_0 = $$createType51;
        const $$createField10_0 = $$createType53;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("idle" in $$parsedSource) {
            $$parsedSource["idle"] = $$createField1_0($$parsedSource["idle"]);
        }
        if ("queued" in $$parsedSource) {
            $$parsedSource["queued"] = $$createField2_0($$parsedSource["queued"]);
        }
        if ("backingUp" in $$parsedSource) {
            $$parsedSource["backingUp"] = $$createField3_0($$parsedSource["backingUp"]);
        }
        if ("pruning" in $$parsedSource) {
            $$parsedSource["pruning"] = $$createField4_0($$parsedSource["pruning"]);
        }
        if ("deleting" in $$parsedSource) {
            $$parsedSource["deleting"] = $$createField5_0($$parsedSource["deleting"]);
        }
        if ("refreshing" in $$parsedSource) {
            $$parsedSource["refreshing"] = $$createField6_0($$parsedSource["refreshing"]);
        }
        if ("checking" in $$parsedSource) {
            $$parsedSource["checking"] = $$createField7_0($$parsedSource["checking"]);
        }
        if ("mounting" in $$parsedSource) {
            $$parsedSource["mounting"] = $$createField8_0($$parsedSource["mounting"]);
        }
        if ("mounted" in $$parsedSource) {
            $$parsedSource["mounted"] = $$createField9_0($$parsedSource["mounted"]);
        }
        if ("error" in $$parsedSource) {
            $$parsedSource["error"] = $$createField10_0($$parsedSource["error"]);
        }
        return new RepositoryStateUnion($$parsedSource as Partial<RepositoryStateUnion>);
    }
}

export class Unmount {
    "repositoryId": number;
    "mountPath": string;

    /** Creates a new Unmount instance. */
    constructor($$source: Partial<Unmount> = {}) {
        if (!("repositoryId" in $$source)) {
            this["repositoryId"] = 0;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Unmount instance from a string or object.
     */
    static createFrom($$source: any = {}): Unmount {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Unmount($$parsedSource as Partial<Unmount>);
    }
}

export class UnmountArchive {
    "archiveId": number;
    "mountPath": string;

    /** Creates a new UnmountArchive instance. */
    constructor($$source: Partial<UnmountArchive> = {}) {
        if (!("archiveId" in $$source)) {
            this["archiveId"] = 0;
        }
        if (!("mountPath" in $$source)) {
            this["mountPath"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new UnmountArchive instance from a string or object.
     */
    static createFrom($$source: any = {}): UnmountArchive {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new UnmountArchive($$parsedSource as Partial<UnmountArchive>);
    }
}

// Private type creation functions
const $$createType0 = Backup.createFrom;
const $$createType1 = types$0.BackupId.createFrom;
const $$createType2 = types$1.BackupProgress.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = ent$0.PruningRule.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
const $$createType6 = MountInfo.createFrom;
const $$createType7 = $Create.Array($$createType6);
const $$createType8 = $Create.Nullable($$createType0);
const $$createType9 = Prune.createFrom;
const $$createType10 = $Create.Nullable($$createType9);
const $$createType11 = Delete.createFrom;
const $$createType12 = $Create.Nullable($$createType11);
const $$createType13 = ArchiveRefresh.createFrom;
const $$createType14 = $Create.Nullable($$createType13);
const $$createType15 = ArchiveDelete.createFrom;
const $$createType16 = $Create.Nullable($$createType15);
const $$createType17 = ArchiveRename.createFrom;
const $$createType18 = $Create.Nullable($$createType17);
const $$createType19 = ArchiveComment.createFrom;
const $$createType20 = $Create.Nullable($$createType19);
const $$createType21 = Mount.createFrom;
const $$createType22 = $Create.Nullable($$createType21);
const $$createType23 = MountArchive.createFrom;
const $$createType24 = $Create.Nullable($$createType23);
const $$createType25 = Unmount.createFrom;
const $$createType26 = $Create.Nullable($$createType25);
const $$createType27 = UnmountArchive.createFrom;
const $$createType28 = $Create.Nullable($$createType27);
const $$createType29 = ExaminePrune.createFrom;
const $$createType30 = $Create.Nullable($$createType29);
const $$createType31 = Check.createFrom;
const $$createType32 = $Create.Nullable($$createType31);
const $$createType33 = OperationUnion.createFrom;
const $$createType34 = Idle.createFrom;
const $$createType35 = $Create.Nullable($$createType34);
const $$createType36 = Queued.createFrom;
const $$createType37 = $Create.Nullable($$createType36);
const $$createType38 = BackingUp.createFrom;
const $$createType39 = $Create.Nullable($$createType38);
const $$createType40 = Pruning.createFrom;
const $$createType41 = $Create.Nullable($$createType40);
const $$createType42 = Deleting.createFrom;
const $$createType43 = $Create.Nullable($$createType42);
const $$createType44 = Refreshing.createFrom;
const $$createType45 = $Create.Nullable($$createType44);
const $$createType46 = Checking.createFrom;
const $$createType47 = $Create.Nullable($$createType46);
const $$createType48 = Mounting.createFrom;
const $$createType49 = $Create.Nullable($$createType48);
const $$createType50 = Mounted.createFrom;
const $$createType51 = $Create.Nullable($$createType50);
const $$createType52 = Error.createFrom;
const $$createType53 = $Create.Nullable($$createType52);
