// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as timestamppb$0 from "../../../../../../google.golang.org/protobuf/types/known/timestamppb/models.js";

/**
 * CancelSubscriptionResponse confirms cancellation scheduling.
 * 
 * Indicates successful cancellation scheduling and when access will end.
 * Users can still reactivate before the effective date.
 */
export class CancelSubscriptionResponse {
    /**
     * Whether the cancellation was successfully scheduled.
     */
    "success"?: boolean;

    /**
     * When the subscription will actually end.
     * Users retain access until this time.
     */
    "effective_date"?: timestamppb$0.Timestamp | null;

    /** Creates a new CancelSubscriptionResponse instance. */
    constructor($$source: Partial<CancelSubscriptionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CancelSubscriptionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): CancelSubscriptionResponse {
        const $$createField1_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("effective_date" in $$parsedSource) {
            $$parsedSource["effective_date"] = $$createField1_0($$parsedSource["effective_date"]);
        }
        return new CancelSubscriptionResponse($$parsedSource as Partial<CancelSubscriptionResponse>);
    }
}

/**
 * CreateCheckoutSessionResponse contains payment checkout session details.
 * 
 * Provides the checkout URL for payment completion and session ID
 * for tracking payment status via WaitForCheckoutCompletion.
 */
export class CreateCheckoutSessionResponse {
    /**
     * Checkout session ID for tracking.
     * Use this with WaitForCheckoutCompletion for real-time updates.
     */
    "session_id"?: string;

    /**
     * Checkout URL for payment completion.
     * Users should be redirected to this URL to complete payment.
     */
    "checkout_url"?: string;

    /** Creates a new CreateCheckoutSessionResponse instance. */
    constructor($$source: Partial<CreateCheckoutSessionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CreateCheckoutSessionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): CreateCheckoutSessionResponse {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new CreateCheckoutSessionResponse($$parsedSource as Partial<CreateCheckoutSessionResponse>);
    }
}

/**
 * DowngradeSubscriptionResponse confirms downgrade scheduling.
 * 
 * Indicates successful downgrade scheduling with effect at end of current billing period.
 */
export class DowngradeSubscriptionResponse {
    /**
     * Whether the downgrade was successfully scheduled.
     */
    "success"?: boolean;

    /**
     * When the downgrade will take effect.
     * Always at the end of the current billing period.
     */
    "effective_date"?: timestamppb$0.Timestamp | null;

    /** Creates a new DowngradeSubscriptionResponse instance. */
    constructor($$source: Partial<DowngradeSubscriptionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new DowngradeSubscriptionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): DowngradeSubscriptionResponse {
        const $$createField1_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("effective_date" in $$parsedSource) {
            $$parsedSource["effective_date"] = $$createField1_0($$parsedSource["effective_date"]);
        }
        return new DowngradeSubscriptionResponse($$parsedSource as Partial<DowngradeSubscriptionResponse>);
    }
}

/**
 * GetSubscriptionResponse contains the user's subscription details.
 * 
 * Returns null subscription field if the user has no active subscription.
 */
export class GetSubscriptionResponse {
    /**
     * The user's current subscription.
     * Null if the user has no active subscription.
     */
    "subscription"?: Subscription | null;

    /** Creates a new GetSubscriptionResponse instance. */
    constructor($$source: Partial<GetSubscriptionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new GetSubscriptionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): GetSubscriptionResponse {
        const $$createField0_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("subscription" in $$parsedSource) {
            $$parsedSource["subscription"] = $$createField0_0($$parsedSource["subscription"]);
        }
        return new GetSubscriptionResponse($$parsedSource as Partial<GetSubscriptionResponse>);
    }
}

/**
 * Plan represents a complete subscription plan with pricing and features.
 * 
 * Each plan is sourced from Polar products and contains all necessary
 * information for displaying plans and handling subscriptions.
 */
export class Plan {
    /**
     * ID is the product ID of Polar used for checkout sessions and subscriptions
     */
    "id"?: string;

    /**
     * Human-readable plan name (e.g., "Arco Cloud - Lite", "Arco Cloud - Pro").
     */
    "name"?: string;

    /**
     * Plan description with storage and pricing details.
     */
    "description"?: string;

    /**
     * Base storage limit in GB included in the plan.
     */
    "storage_gb"?: number;

    /**
     * Maximum number of repositories allowed for this plan.
     */
    "allowed_repositories"?: number;

    /**
     * Whether this plan should be highlighted as popular/recommended.
     */
    "popular"?: boolean;

    /**
     * Base yearly subscription price in cents (e.g., 2400 = $24.00).
     */
    "price_cents"?: number;

    /**
     * Overage pricing per GB in cents for usage beyond base storage limit.
     */
    "overage_cents_per_gb"?: number;

    /** Creates a new Plan instance. */
    constructor($$source: Partial<Plan> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Plan instance from a string or object.
     */
    static createFrom($$source: any = {}): Plan {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new Plan($$parsedSource as Partial<Plan>);
    }
}

/**
 * ReactivateSubscriptionResponse confirms cancellation removal.
 * 
 * Indicates successful reactivation of a previously canceled subscription.
 */
export class ReactivateSubscriptionResponse {
    /**
     * Whether the reactivation was successful.
     */
    "success"?: boolean;

    /** Creates a new ReactivateSubscriptionResponse instance. */
    constructor($$source: Partial<ReactivateSubscriptionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new ReactivateSubscriptionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): ReactivateSubscriptionResponse {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new ReactivateSubscriptionResponse($$parsedSource as Partial<ReactivateSubscriptionResponse>);
    }
}

/**
 * RepositoryLocation represents the geographical location of a ArcoCloud repository.
 * 
 * ArcoCloud provides repositories in multiple regions for data sovereignty
 * and performance optimization based on user location.
 */
export enum RepositoryLocation {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * Default unspecified location.
     */
    RepositoryLocation_REPOSITORY_LOCATION_UNSPECIFIED = 0,

    /**
     * United States region for repositories.
     * Provides optimal performance for North American users.
     */
    RepositoryLocation_REPOSITORY_LOCATION_US = 1,

    /**
     * European Union region for repositories.
     * Ensures GDPR compliance and optimal performance for European users.
     */
    RepositoryLocation_REPOSITORY_LOCATION_EU = 2,
};

/**
 * Subscription represents a user's active subscription with complete details.
 * 
 * Contains subscription metadata, billing information, usage tracking,
 * and plan details.
 */
export class Subscription {
    /**
     * Unique subscription identifier.
     */
    "id"?: string;

    /**
     * Plan identifier (e.g., "BASIC", "PRO").
     */
    "plan_id"?: string;

    /**
     * Current subscription status.
     */
    "status"?: SubscriptionStatus;

    /**
     * Start of the current billing period.
     */
    "current_period_start"?: timestamppb$0.Timestamp | null;

    /**
     * End of the current billing period.
     * New billing cycles begin immediately after this time.
     */
    "current_period_end"?: timestamppb$0.Timestamp | null;

    /**
     * Whether the subscription will cancel at the end of the current period.
     * If true, subscription ends at current_period_end without renewal.
     */
    "cancel_at_period_end"?: boolean;

    /**
     * When the subscription was canceled (if applicable).
     * Set when cancel_at_period_end is enabled.
     */
    "canceled_at"?: timestamppb$0.Timestamp | null;

    /**
     * When the subscription was originally created.
     */
    "created_at"?: timestamppb$0.Timestamp | null;

    /**
     * When the subscription was last updated.
     */
    "updated_at"?: timestamppb$0.Timestamp | null;

    /**
     * Complete plan details including pricing and features.
     */
    "plan"?: Plan | null;

    /**
     * Current storage usage in GB.
     */
    "storage_used_gb"?: number;

    /**
     * Maximum storage allowed before overage charges apply.
     */
    "storage_limit_gb"?: number;

    /**
     * Overage rate per GB in cents.
     */
    "overage_rate_per_gb_cents"?: number;

    /** Creates a new Subscription instance. */
    constructor($$source: Partial<Subscription> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Subscription instance from a string or object.
     */
    static createFrom($$source: any = {}): Subscription {
        const $$createField3_0 = $$createType1;
        const $$createField4_0 = $$createType1;
        const $$createField6_0 = $$createType1;
        const $$createField7_0 = $$createType1;
        const $$createField8_0 = $$createType1;
        const $$createField9_0 = $$createType5;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("current_period_start" in $$parsedSource) {
            $$parsedSource["current_period_start"] = $$createField3_0($$parsedSource["current_period_start"]);
        }
        if ("current_period_end" in $$parsedSource) {
            $$parsedSource["current_period_end"] = $$createField4_0($$parsedSource["current_period_end"]);
        }
        if ("canceled_at" in $$parsedSource) {
            $$parsedSource["canceled_at"] = $$createField6_0($$parsedSource["canceled_at"]);
        }
        if ("created_at" in $$parsedSource) {
            $$parsedSource["created_at"] = $$createField7_0($$parsedSource["created_at"]);
        }
        if ("updated_at" in $$parsedSource) {
            $$parsedSource["updated_at"] = $$createField8_0($$parsedSource["updated_at"]);
        }
        if ("plan" in $$parsedSource) {
            $$parsedSource["plan"] = $$createField9_0($$parsedSource["plan"]);
        }
        return new Subscription($$parsedSource as Partial<Subscription>);
    }
}

/**
 * SubscriptionStatus represents the current state of a subscription.
 * 
 * These statuses determine subscription behavior and access permissions.
 */
export enum SubscriptionStatus {
    /**
     * The Go zero value for the underlying type of the enum.
     */
    $zero = 0,

    /**
     * Default unspecified status.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_UNSPECIFIED = 0,

    /**
     * Subscription created but payment not completed.
     * User has limited or no access until payment succeeds.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_INCOMPLETE = 1,

    /**
     * Incomplete subscription has expired.
     * Payment was never completed within the allowed timeframe.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_INCOMPLETE_EXPIRED = 2,

    /**
     * Subscription is in trial period.
     * User has full access without payment required yet.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_TRIALING = 3,

    /**
     * Subscription is active and paid.
     * User has full access to plan features.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_ACTIVE = 4,

    /**
     * Payment failed but subscription is still active.
     * User retains access while payment issues are resolved.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_PAST_DUE = 5,

    /**
     * Subscription has been canceled.
     * User loses access at the end of the billing period.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_CANCELED = 6,

    /**
     * Subscription is unpaid and access is revoked.
     * Similar to past_due but with access restrictions.
     */
    SubscriptionStatus_SUBSCRIPTION_STATUS_UNPAID = 7,
};

/**
 * UpgradeSubscriptionResponse confirms immediate upgrade completion.
 * 
 * Indicates successful upgrade with immediate effect and proration.
 */
export class UpgradeSubscriptionResponse {
    /**
     * Whether the upgrade was successful.
     */
    "success"?: boolean;

    /**
     * When the upgrade took effect.
     * Always immediate for upgrades (no delay).
     */
    "effective_date"?: timestamppb$0.Timestamp | null;

    /** Creates a new UpgradeSubscriptionResponse instance. */
    constructor($$source: Partial<UpgradeSubscriptionResponse> = {}) {

        Object.assign(this, $$source);
    }

    /**
     * Creates a new UpgradeSubscriptionResponse instance from a string or object.
     */
    static createFrom($$source: any = {}): UpgradeSubscriptionResponse {
        const $$createField1_0 = $$createType1;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("effective_date" in $$parsedSource) {
            $$parsedSource["effective_date"] = $$createField1_0($$parsedSource["effective_date"]);
        }
        return new UpgradeSubscriptionResponse($$parsedSource as Partial<UpgradeSubscriptionResponse>);
    }
}

// Private type creation functions
const $$createType0 = timestamppb$0.Timestamp.createFrom;
const $$createType1 = $Create.Nullable($$createType0);
const $$createType2 = Subscription.createFrom;
const $$createType3 = $Create.Nullable($$createType2);
const $$createType4 = Plan.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
