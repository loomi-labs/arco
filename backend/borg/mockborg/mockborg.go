// Code generated by MockGen. DO NOT EDIT.
// Source: backend/borg/borg.go
//
// Generated by this command:
//
//	mockgen -source=backend/borg/borg.go -destination=backend/borg/mockborg/mockborg.go --package=mockborg
//

// Package mockborg is a generated GoMock package.
package mockborg

import (
	context "context"
	exec "os/exec"
	reflect "reflect"

	borg "github.com/loomi-labs/arco/backend/borg"
	types "github.com/loomi-labs/arco/backend/borg/types"
	gomock "go.uber.org/mock/gomock"
)

// MockBorg is a mock of Borg interface.
type MockBorg struct {
	ctrl     *gomock.Controller
	recorder *MockBorgMockRecorder
	isgomock struct{}
}

// MockBorgMockRecorder is the mock recorder for MockBorg.
type MockBorgMockRecorder struct {
	mock *MockBorg
}

// NewMockBorg creates a new mock instance.
func NewMockBorg(ctrl *gomock.Controller) *MockBorg {
	mock := &MockBorg{ctrl: ctrl}
	mock.recorder = &MockBorgMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBorg) EXPECT() *MockBorgMockRecorder {
	return m.recorder
}

// BreakLock mocks base method.
func (m *MockBorg) BreakLock(ctx context.Context, repository, password string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BreakLock", ctx, repository, password)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// BreakLock indicates an expected call of BreakLock.
func (mr *MockBorgMockRecorder) BreakLock(ctx, repository, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BreakLock", reflect.TypeOf((*MockBorg)(nil).BreakLock), ctx, repository, password)
}

// Compact mocks base method.
func (m *MockBorg) Compact(ctx context.Context, repository, password string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Compact", ctx, repository, password)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// Compact indicates an expected call of Compact.
func (mr *MockBorgMockRecorder) Compact(ctx, repository, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Compact", reflect.TypeOf((*MockBorg)(nil).Compact), ctx, repository, password)
}

// Create mocks base method.
func (m *MockBorg) Create(ctx context.Context, repository, password, prefix string, backupPaths, excludePaths []string, ch chan types.BackupProgress) (string, *borg.Status) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, repository, password, prefix, backupPaths, excludePaths, ch)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(*borg.Status)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockBorgMockRecorder) Create(ctx, repository, password, prefix, backupPaths, excludePaths, ch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockBorg)(nil).Create), ctx, repository, password, prefix, backupPaths, excludePaths, ch)
}

// DeleteArchive mocks base method.
func (m *MockBorg) DeleteArchive(ctx context.Context, repository, archive, password string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteArchive", ctx, repository, archive, password)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// DeleteArchive indicates an expected call of DeleteArchive.
func (mr *MockBorgMockRecorder) DeleteArchive(ctx, repository, archive, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteArchive", reflect.TypeOf((*MockBorg)(nil).DeleteArchive), ctx, repository, archive, password)
}

// DeleteArchives mocks base method.
func (m *MockBorg) DeleteArchives(ctx context.Context, repository, password, prefix string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteArchives", ctx, repository, password, prefix)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// DeleteArchives indicates an expected call of DeleteArchives.
func (mr *MockBorgMockRecorder) DeleteArchives(ctx, repository, password, prefix any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteArchives", reflect.TypeOf((*MockBorg)(nil).DeleteArchives), ctx, repository, password, prefix)
}

// DeleteRepository mocks base method.
func (m *MockBorg) DeleteRepository(ctx context.Context, repository, password string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteRepository", ctx, repository, password)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// DeleteRepository indicates an expected call of DeleteRepository.
func (mr *MockBorgMockRecorder) DeleteRepository(ctx, repository, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRepository", reflect.TypeOf((*MockBorg)(nil).DeleteRepository), ctx, repository, password)
}

// Info mocks base method.
func (m *MockBorg) Info(ctx context.Context, repository, password string) (*types.InfoResponse, *borg.Status) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info", ctx, repository, password)
	ret0, _ := ret[0].(*types.InfoResponse)
	ret1, _ := ret[1].(*borg.Status)
	return ret0, ret1
}

// Info indicates an expected call of Info.
func (mr *MockBorgMockRecorder) Info(ctx, repository, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockBorg)(nil).Info), ctx, repository, password)
}

// Init mocks base method.
func (m *MockBorg) Init(ctx context.Context, repository, password string, noPassword bool) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init", ctx, repository, password, noPassword)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// Init indicates an expected call of Init.
func (mr *MockBorgMockRecorder) Init(ctx, repository, password, noPassword any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockBorg)(nil).Init), ctx, repository, password, noPassword)
}

// List mocks base method.
func (m *MockBorg) List(ctx context.Context, repository, password string) (*types.ListResponse, *borg.Status) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, repository, password)
	ret0, _ := ret[0].(*types.ListResponse)
	ret1, _ := ret[1].(*borg.Status)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockBorgMockRecorder) List(ctx, repository, password any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockBorg)(nil).List), ctx, repository, password)
}

// MountArchive mocks base method.
func (m *MockBorg) MountArchive(ctx context.Context, repository, archive, password, mountPath string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MountArchive", ctx, repository, archive, password, mountPath)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// MountArchive indicates an expected call of MountArchive.
func (mr *MockBorgMockRecorder) MountArchive(ctx, repository, archive, password, mountPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountArchive", reflect.TypeOf((*MockBorg)(nil).MountArchive), ctx, repository, archive, password, mountPath)
}

// MountRepository mocks base method.
func (m *MockBorg) MountRepository(ctx context.Context, repository, password, mountPath string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MountRepository", ctx, repository, password, mountPath)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// MountRepository indicates an expected call of MountRepository.
func (mr *MockBorgMockRecorder) MountRepository(ctx, repository, password, mountPath any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountRepository", reflect.TypeOf((*MockBorg)(nil).MountRepository), ctx, repository, password, mountPath)
}

// Prune mocks base method.
func (m *MockBorg) Prune(ctx context.Context, repository, password, prefix string, pruneOptions []string, isDryRun bool, ch chan types.PruneResult) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prune", ctx, repository, password, prefix, pruneOptions, isDryRun, ch)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// Prune indicates an expected call of Prune.
func (mr *MockBorgMockRecorder) Prune(ctx, repository, password, prefix, pruneOptions, isDryRun, ch any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prune", reflect.TypeOf((*MockBorg)(nil).Prune), ctx, repository, password, prefix, pruneOptions, isDryRun, ch)
}

// Rename mocks base method.
func (m *MockBorg) Rename(ctx context.Context, repository, archive, password, newName string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rename", ctx, repository, archive, password, newName)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// Rename indicates an expected call of Rename.
func (mr *MockBorgMockRecorder) Rename(ctx, repository, archive, password, newName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rename", reflect.TypeOf((*MockBorg)(nil).Rename), ctx, repository, archive, password, newName)
}

// Umount mocks base method.
func (m *MockBorg) Umount(ctx context.Context, path string) *borg.Status {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Umount", ctx, path)
	ret0, _ := ret[0].(*borg.Status)
	return ret0
}

// Umount indicates an expected call of Umount.
func (mr *MockBorgMockRecorder) Umount(ctx, path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Umount", reflect.TypeOf((*MockBorg)(nil).Umount), ctx, path)
}

// MockCommandRunner is a mock of CommandRunner interface.
type MockCommandRunner struct {
	ctrl     *gomock.Controller
	recorder *MockCommandRunnerMockRecorder
	isgomock struct{}
}

// MockCommandRunnerMockRecorder is the mock recorder for MockCommandRunner.
type MockCommandRunnerMockRecorder struct {
	mock *MockCommandRunner
}

// NewMockCommandRunner creates a new mock instance.
func NewMockCommandRunner(ctrl *gomock.Controller) *MockCommandRunner {
	mock := &MockCommandRunner{ctrl: ctrl}
	mock.recorder = &MockCommandRunnerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandRunner) EXPECT() *MockCommandRunnerMockRecorder {
	return m.recorder
}

// Info mocks base method.
func (m *MockCommandRunner) Info(cmd *exec.Cmd) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info", cmd)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Info indicates an expected call of Info.
func (mr *MockCommandRunnerMockRecorder) Info(cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockCommandRunner)(nil).Info), cmd)
}
