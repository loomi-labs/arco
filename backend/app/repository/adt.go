// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package repository

import (
	"github.com/chris-tomich/adtenum"
	"github.com/negrel/assert"
)

// ArchiveDeleteStateType is the discriminator enum for ArchiveDeleteState
type ArchiveDeleteStateType string

const (
	ArchiveDeleteStateTypeDeleteActive ArchiveDeleteStateType = "DeleteActive"
	ArchiveDeleteStateTypeDeleteNone   ArchiveDeleteStateType = "DeleteNone"
	ArchiveDeleteStateTypeDeleteQueued ArchiveDeleteStateType = "DeleteQueued"
)

// ArchiveDeleteState variant wrappers
type DeleteActiveVariant adtenum.OneVariantValue[DeleteActive]
type DeleteNoneVariant adtenum.OneVariantValue[DeleteNone]
type DeleteQueuedVariant adtenum.OneVariantValue[DeleteQueued]

// ArchiveDeleteState constructors
var NewArchiveDeleteStateDeleteActive = adtenum.CreateOneVariantValueConstructor[DeleteActiveVariant]()
var NewArchiveDeleteStateDeleteNone = adtenum.CreateOneVariantValueConstructor[DeleteNoneVariant]()
var NewArchiveDeleteStateDeleteQueued = adtenum.CreateOneVariantValueConstructor[DeleteQueuedVariant]()

// EnumType methods for ArchiveDeleteState variants
func (v DeleteActiveVariant) EnumType() ArchiveDeleteState { return v }
func (v DeleteNoneVariant) EnumType() ArchiveDeleteState   { return v }
func (v DeleteQueuedVariant) EnumType() ArchiveDeleteState { return v }

// GetArchiveDeleteStateType returns the discriminator type for exhaustive switch checking
func GetArchiveDeleteStateType(enum ArchiveDeleteState) ArchiveDeleteStateType {
	switch enum.(type) {
	case DeleteNoneVariant:
		return ArchiveDeleteStateTypeDeleteNone
	case DeleteQueuedVariant:
		return ArchiveDeleteStateTypeDeleteQueued
	case DeleteActiveVariant:
		return ArchiveDeleteStateTypeDeleteActive
	default:
		assert.Fail("Unhandled ArchiveDeleteState variant in GetArchiveDeleteStateType")
		return ArchiveDeleteStateTypeDeleteActive
	}
}

// ArchiveDeleteStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type ArchiveDeleteStateUnion struct {
	Type ArchiveDeleteStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	DeleteNone   *DeleteNone   `json:"deleteNone,omitempty"`
	DeleteQueued *DeleteQueued `json:"deleteQueued,omitempty"`
	DeleteActive *DeleteActive `json:"deleteActive,omitempty"`
}

// ToArchiveDeleteStateUnion converts an ADT ArchiveDeleteState to an ArchiveDeleteStateUnion
func ToArchiveDeleteStateUnion(r ArchiveDeleteState) ArchiveDeleteStateUnion {
	switch i := r.(type) {
	case DeleteNoneVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:       ArchiveDeleteStateTypeDeleteNone,
			DeleteNone: &data,
		}
	case DeleteQueuedVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteQueued,
			DeleteQueued: &data,
		}
	case DeleteActiveVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteActive,
			DeleteActive: &data,
		}
	default:
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteActive,
			DeleteActive: &DeleteActive{},
		}
	}
}

// ArchiveEditStateType is the discriminator enum for ArchiveEditState
type ArchiveEditStateType string

const (
	ArchiveEditStateTypeEditActive ArchiveEditStateType = "EditActive"
	ArchiveEditStateTypeEditNone   ArchiveEditStateType = "EditNone"
	ArchiveEditStateTypeEditQueued ArchiveEditStateType = "EditQueued"
)

// ArchiveEditState variant wrappers
type EditActiveVariant adtenum.OneVariantValue[EditActive]
type EditNoneVariant adtenum.OneVariantValue[EditNone]
type EditQueuedVariant adtenum.OneVariantValue[EditQueued]

// ArchiveEditState constructors
var NewArchiveEditStateEditActive = adtenum.CreateOneVariantValueConstructor[EditActiveVariant]()
var NewArchiveEditStateEditNone = adtenum.CreateOneVariantValueConstructor[EditNoneVariant]()
var NewArchiveEditStateEditQueued = adtenum.CreateOneVariantValueConstructor[EditQueuedVariant]()

// EnumType methods for ArchiveEditState variants
func (v EditActiveVariant) EnumType() ArchiveEditState { return v }
func (v EditNoneVariant) EnumType() ArchiveEditState   { return v }
func (v EditQueuedVariant) EnumType() ArchiveEditState { return v }

// GetArchiveEditStateType returns the discriminator type for exhaustive switch checking
func GetArchiveEditStateType(enum ArchiveEditState) ArchiveEditStateType {
	switch enum.(type) {
	case EditNoneVariant:
		return ArchiveEditStateTypeEditNone
	case EditQueuedVariant:
		return ArchiveEditStateTypeEditQueued
	case EditActiveVariant:
		return ArchiveEditStateTypeEditActive
	default:
		assert.Fail("Unhandled ArchiveEditState variant in GetArchiveEditStateType")
		return ArchiveEditStateTypeEditActive
	}
}

// ArchiveEditStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type ArchiveEditStateUnion struct {
	Type ArchiveEditStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	EditNone   *EditNone   `json:"editNone,omitempty"`
	EditQueued *EditQueued `json:"editQueued,omitempty"`
	EditActive *EditActive `json:"editActive,omitempty"`
}

// ToArchiveEditStateUnion converts an ADT ArchiveEditState to an ArchiveEditStateUnion
func ToArchiveEditStateUnion(r ArchiveEditState) ArchiveEditStateUnion {
	switch i := r.(type) {
	case EditNoneVariant:
		data := i()
		return ArchiveEditStateUnion{
			Type:     ArchiveEditStateTypeEditNone,
			EditNone: &data,
		}
	case EditQueuedVariant:
		data := i()
		return ArchiveEditStateUnion{
			Type:       ArchiveEditStateTypeEditQueued,
			EditQueued: &data,
		}
	case EditActiveVariant:
		data := i()
		return ArchiveEditStateUnion{
			Type:       ArchiveEditStateTypeEditActive,
			EditActive: &data,
		}
	default:
		return ArchiveEditStateUnion{
			Type:       ArchiveEditStateTypeEditActive,
			EditActive: &EditActive{},
		}
	}
}

// LocationType is the discriminator enum for Location
type LocationType string

const (
	LocationTypeArcoCloud LocationType = "ArcoCloud"
	LocationTypeLocal     LocationType = "Local"
	LocationTypeRemote    LocationType = "Remote"
)

// Location variant wrappers
type ArcoCloudVariant adtenum.OneVariantValue[ArcoCloud]
type LocalVariant adtenum.OneVariantValue[Local]
type RemoteVariant adtenum.OneVariantValue[Remote]

// Location constructors
var NewLocationArcoCloud = adtenum.CreateOneVariantValueConstructor[ArcoCloudVariant]()
var NewLocationLocal = adtenum.CreateOneVariantValueConstructor[LocalVariant]()
var NewLocationRemote = adtenum.CreateOneVariantValueConstructor[RemoteVariant]()

// EnumType methods for Location variants
func (v ArcoCloudVariant) EnumType() Location { return v }
func (v LocalVariant) EnumType() Location     { return v }
func (v RemoteVariant) EnumType() Location    { return v }

// GetLocationType returns the discriminator type for exhaustive switch checking
func GetLocationType(enum Location) LocationType {
	switch enum.(type) {
	case LocalVariant:
		return LocationTypeLocal
	case RemoteVariant:
		return LocationTypeRemote
	case ArcoCloudVariant:
		return LocationTypeArcoCloud
	default:
		assert.Fail("Unhandled Location variant in GetLocationType")
		return LocationTypeArcoCloud
	}
}

// LocationUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type LocationUnion struct {
	Type LocationType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Local     *Local     `json:"local,omitempty"`
	Remote    *Remote    `json:"remote,omitempty"`
	ArcoCloud *ArcoCloud `json:"arcoCloud,omitempty"`
}

// ToLocationUnion converts an ADT Location to an LocationUnion
func ToLocationUnion(r Location) LocationUnion {
	switch i := r.(type) {
	case LocalVariant:
		data := i()
		return LocationUnion{
			Type:  LocationTypeLocal,
			Local: &data,
		}
	case RemoteVariant:
		data := i()
		return LocationUnion{
			Type:   LocationTypeRemote,
			Remote: &data,
		}
	case ArcoCloudVariant:
		data := i()
		return LocationUnion{
			Type:      LocationTypeArcoCloud,
			ArcoCloud: &data,
		}
	default:
		return LocationUnion{
			Type:      LocationTypeArcoCloud,
			ArcoCloud: &ArcoCloud{},
		}
	}
}

// OperationStatusType is the discriminator enum for OperationStatus
type OperationStatusType string

const (
	OperationStatusTypeCompleted OperationStatusType = "Completed"
	OperationStatusTypeExpired   OperationStatusType = "Expired"
	OperationStatusTypeFailed    OperationStatusType = "Failed"
	OperationStatusTypeQueued    OperationStatusType = "Queued"
	OperationStatusTypeRunning   OperationStatusType = "Running"
)

// OperationStatus variant wrappers
type CompletedVariant adtenum.OneVariantValue[Completed]
type ExpiredVariant adtenum.OneVariantValue[Expired]
type FailedVariant adtenum.OneVariantValue[Failed]
type QueuedVariant adtenum.OneVariantValue[Queued]
type RunningVariant adtenum.OneVariantValue[Running]

// OperationStatus constructors
var NewOperationStatusCompleted = adtenum.CreateOneVariantValueConstructor[CompletedVariant]()
var NewOperationStatusExpired = adtenum.CreateOneVariantValueConstructor[ExpiredVariant]()
var NewOperationStatusFailed = adtenum.CreateOneVariantValueConstructor[FailedVariant]()
var NewOperationStatusQueued = adtenum.CreateOneVariantValueConstructor[QueuedVariant]()
var NewOperationStatusRunning = adtenum.CreateOneVariantValueConstructor[RunningVariant]()

// EnumType methods for OperationStatus variants
func (v CompletedVariant) EnumType() OperationStatus { return v }
func (v ExpiredVariant) EnumType() OperationStatus   { return v }
func (v FailedVariant) EnumType() OperationStatus    { return v }
func (v QueuedVariant) EnumType() OperationStatus    { return v }
func (v RunningVariant) EnumType() OperationStatus   { return v }

// GetOperationStatusType returns the discriminator type for exhaustive switch checking
func GetOperationStatusType(enum OperationStatus) OperationStatusType {
	switch enum.(type) {
	case QueuedVariant:
		return OperationStatusTypeQueued
	case RunningVariant:
		return OperationStatusTypeRunning
	case CompletedVariant:
		return OperationStatusTypeCompleted
	case FailedVariant:
		return OperationStatusTypeFailed
	case ExpiredVariant:
		return OperationStatusTypeExpired
	default:
		assert.Fail("Unhandled OperationStatus variant in GetOperationStatusType")
		return OperationStatusTypeCompleted
	}
}

// OperationStatusUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type OperationStatusUnion struct {
	Type OperationStatusType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Queued    *Queued    `json:"queued,omitempty"`
	Running   *Running   `json:"running,omitempty"`
	Completed *Completed `json:"completed,omitempty"`
	Failed    *Failed    `json:"failed,omitempty"`
	Expired   *Expired   `json:"expired,omitempty"`
}

// ToOperationStatusUnion converts an ADT OperationStatus to an OperationStatusUnion
func ToOperationStatusUnion(r OperationStatus) OperationStatusUnion {
	switch i := r.(type) {
	case QueuedVariant:
		data := i()
		return OperationStatusUnion{
			Type:   OperationStatusTypeQueued,
			Queued: &data,
		}
	case RunningVariant:
		data := i()
		return OperationStatusUnion{
			Type:    OperationStatusTypeRunning,
			Running: &data,
		}
	case CompletedVariant:
		data := i()
		return OperationStatusUnion{
			Type:      OperationStatusTypeCompleted,
			Completed: &data,
		}
	case FailedVariant:
		data := i()
		return OperationStatusUnion{
			Type:   OperationStatusTypeFailed,
			Failed: &data,
		}
	case ExpiredVariant:
		data := i()
		return OperationStatusUnion{
			Type:    OperationStatusTypeExpired,
			Expired: &data,
		}
	default:
		return OperationStatusUnion{
			Type:      OperationStatusTypeCompleted,
			Completed: &Completed{},
		}
	}
}
