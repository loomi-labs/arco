// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package repository

import (
	"github.com/chris-tomich/adtenum"
	"github.com/negrel/assert"
)

// LocationType is the discriminator enum for Location
type LocationType string

const (
	LocationTypeArcoCloud LocationType = "ArcoCloud"
	LocationTypeLocal     LocationType = "Local"
	LocationTypeRemote    LocationType = "Remote"
)

// Location variant wrappers
type ArcoCloudVariant adtenum.OneVariantValue[ArcoCloud]
type LocalVariant adtenum.OneVariantValue[Local]
type RemoteVariant adtenum.OneVariantValue[Remote]

// Location constructors
var NewLocationArcoCloud = adtenum.CreateOneVariantValueConstructor[ArcoCloudVariant]()
var NewLocationLocal = adtenum.CreateOneVariantValueConstructor[LocalVariant]()
var NewLocationRemote = adtenum.CreateOneVariantValueConstructor[RemoteVariant]()

// EnumType methods for Location variants
func (v ArcoCloudVariant) EnumType() Location { return v }
func (v LocalVariant) EnumType() Location     { return v }
func (v RemoteVariant) EnumType() Location    { return v }

// GetLocationType returns the discriminator type for exhaustive switch checking
func GetLocationType(enum Location) LocationType {
	switch enum.(type) {
	case LocalVariant:
		return LocationTypeLocal
	case RemoteVariant:
		return LocationTypeRemote
	case ArcoCloudVariant:
		return LocationTypeArcoCloud
	default:
		assert.Fail("Unhandled Location variant in GetLocationType")
		return LocationTypeArcoCloud
	}
}

// LocationUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type LocationUnion struct {
	Type LocationType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Local     *Local     `json:"local,omitempty"`
	Remote    *Remote    `json:"remote,omitempty"`
	ArcoCloud *ArcoCloud `json:"arcoCloud,omitempty"`
}

// ToLocationUnion converts an ADT Location to an LocationUnion
func ToLocationUnion(r Location) LocationUnion {
	switch i := r.(type) {
	case LocalVariant:
		data := i()
		return LocationUnion{
			Type:  LocationTypeLocal,
			Local: &data,
		}
	case RemoteVariant:
		data := i()
		return LocationUnion{
			Type:   LocationTypeRemote,
			Remote: &data,
		}
	case ArcoCloudVariant:
		data := i()
		return LocationUnion{
			Type:      LocationTypeArcoCloud,
			ArcoCloud: &data,
		}
	default:
		return LocationUnion{
			Type:      LocationTypeArcoCloud,
			ArcoCloud: &ArcoCloud{},
		}
	}
}

// OperationStatusType is the discriminator enum for OperationStatus
type OperationStatusType string

const (
	OperationStatusTypeCompleted OperationStatusType = "Completed"
	OperationStatusTypeExpired   OperationStatusType = "Expired"
	OperationStatusTypeFailed    OperationStatusType = "Failed"
	OperationStatusTypeQueued    OperationStatusType = "Queued"
	OperationStatusTypeRunning   OperationStatusType = "Running"
)

// OperationStatus variant wrappers
type CompletedVariant adtenum.OneVariantValue[Completed]
type ExpiredVariant adtenum.OneVariantValue[Expired]
type FailedVariant adtenum.OneVariantValue[Failed]
type QueuedVariant adtenum.OneVariantValue[Queued]
type RunningVariant adtenum.OneVariantValue[Running]

// OperationStatus constructors
var NewOperationStatusCompleted = adtenum.CreateOneVariantValueConstructor[CompletedVariant]()
var NewOperationStatusExpired = adtenum.CreateOneVariantValueConstructor[ExpiredVariant]()
var NewOperationStatusFailed = adtenum.CreateOneVariantValueConstructor[FailedVariant]()
var NewOperationStatusQueued = adtenum.CreateOneVariantValueConstructor[QueuedVariant]()
var NewOperationStatusRunning = adtenum.CreateOneVariantValueConstructor[RunningVariant]()

// EnumType methods for OperationStatus variants
func (v CompletedVariant) EnumType() OperationStatus { return v }
func (v ExpiredVariant) EnumType() OperationStatus   { return v }
func (v FailedVariant) EnumType() OperationStatus    { return v }
func (v QueuedVariant) EnumType() OperationStatus    { return v }
func (v RunningVariant) EnumType() OperationStatus   { return v }

// GetOperationStatusType returns the discriminator type for exhaustive switch checking
func GetOperationStatusType(enum OperationStatus) OperationStatusType {
	switch enum.(type) {
	case QueuedVariant:
		return OperationStatusTypeQueued
	case RunningVariant:
		return OperationStatusTypeRunning
	case CompletedVariant:
		return OperationStatusTypeCompleted
	case FailedVariant:
		return OperationStatusTypeFailed
	case ExpiredVariant:
		return OperationStatusTypeExpired
	default:
		assert.Fail("Unhandled OperationStatus variant in GetOperationStatusType")
		return OperationStatusTypeCompleted
	}
}

// OperationStatusUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type OperationStatusUnion struct {
	Type OperationStatusType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Queued    *Queued    `json:"queued,omitempty"`
	Running   *Running   `json:"running,omitempty"`
	Completed *Completed `json:"completed,omitempty"`
	Failed    *Failed    `json:"failed,omitempty"`
	Expired   *Expired   `json:"expired,omitempty"`
}

// ToOperationStatusUnion converts an ADT OperationStatus to an OperationStatusUnion
func ToOperationStatusUnion(r OperationStatus) OperationStatusUnion {
	switch i := r.(type) {
	case QueuedVariant:
		data := i()
		return OperationStatusUnion{
			Type:   OperationStatusTypeQueued,
			Queued: &data,
		}
	case RunningVariant:
		data := i()
		return OperationStatusUnion{
			Type:    OperationStatusTypeRunning,
			Running: &data,
		}
	case CompletedVariant:
		data := i()
		return OperationStatusUnion{
			Type:      OperationStatusTypeCompleted,
			Completed: &data,
		}
	case FailedVariant:
		data := i()
		return OperationStatusUnion{
			Type:   OperationStatusTypeFailed,
			Failed: &data,
		}
	case ExpiredVariant:
		data := i()
		return OperationStatusUnion{
			Type:    OperationStatusTypeExpired,
			Expired: &data,
		}
	default:
		return OperationStatusUnion{
			Type:      OperationStatusTypeCompleted,
			Completed: &Completed{},
		}
	}
}

// ArchiveRenameStateType is the discriminator enum for ArchiveRenameState
type ArchiveRenameStateType string

const (
	ArchiveRenameStateTypeRenameActive ArchiveRenameStateType = "RenameActive"
	ArchiveRenameStateTypeRenameNone   ArchiveRenameStateType = "RenameNone"
	ArchiveRenameStateTypeRenameQueued ArchiveRenameStateType = "RenameQueued"
)

// ArchiveRenameState variant wrappers
type RenameActiveVariant adtenum.OneVariantValue[RenameActive]
type RenameNoneVariant adtenum.OneVariantValue[RenameNone]
type RenameQueuedVariant adtenum.OneVariantValue[RenameQueued]

// ArchiveRenameState constructors
var NewArchiveRenameStateRenameActive = adtenum.CreateOneVariantValueConstructor[RenameActiveVariant]()
var NewArchiveRenameStateRenameNone = adtenum.CreateOneVariantValueConstructor[RenameNoneVariant]()
var NewArchiveRenameStateRenameQueued = adtenum.CreateOneVariantValueConstructor[RenameQueuedVariant]()

// EnumType methods for ArchiveRenameState variants
func (v RenameActiveVariant) EnumType() ArchiveRenameState { return v }
func (v RenameNoneVariant) EnumType() ArchiveRenameState   { return v }
func (v RenameQueuedVariant) EnumType() ArchiveRenameState { return v }

// GetArchiveRenameStateType returns the discriminator type for exhaustive switch checking
func GetArchiveRenameStateType(enum ArchiveRenameState) ArchiveRenameStateType {
	switch enum.(type) {
	case RenameNoneVariant:
		return ArchiveRenameStateTypeRenameNone
	case RenameQueuedVariant:
		return ArchiveRenameStateTypeRenameQueued
	case RenameActiveVariant:
		return ArchiveRenameStateTypeRenameActive
	default:
		assert.Fail("Unhandled ArchiveRenameState variant in GetArchiveRenameStateType")
		return ArchiveRenameStateTypeRenameActive
	}
}

// ArchiveRenameStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type ArchiveRenameStateUnion struct {
	Type ArchiveRenameStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	RenameNone   *RenameNone   `json:"renameNone,omitempty"`
	RenameQueued *RenameQueued `json:"renameQueued,omitempty"`
	RenameActive *RenameActive `json:"renameActive,omitempty"`
}

// ToArchiveRenameStateUnion converts an ADT ArchiveRenameState to an ArchiveRenameStateUnion
func ToArchiveRenameStateUnion(r ArchiveRenameState) ArchiveRenameStateUnion {
	switch i := r.(type) {
	case RenameNoneVariant:
		data := i()
		return ArchiveRenameStateUnion{
			Type:       ArchiveRenameStateTypeRenameNone,
			RenameNone: &data,
		}
	case RenameQueuedVariant:
		data := i()
		return ArchiveRenameStateUnion{
			Type:         ArchiveRenameStateTypeRenameQueued,
			RenameQueued: &data,
		}
	case RenameActiveVariant:
		data := i()
		return ArchiveRenameStateUnion{
			Type:         ArchiveRenameStateTypeRenameActive,
			RenameActive: &data,
		}
	default:
		return ArchiveRenameStateUnion{
			Type:         ArchiveRenameStateTypeRenameActive,
			RenameActive: &RenameActive{},
		}
	}
}

// ArchiveDeleteStateType is the discriminator enum for ArchiveDeleteState
type ArchiveDeleteStateType string

const (
	ArchiveDeleteStateTypeDeleteActive ArchiveDeleteStateType = "DeleteActive"
	ArchiveDeleteStateTypeDeleteNone   ArchiveDeleteStateType = "DeleteNone"
	ArchiveDeleteStateTypeDeleteQueued ArchiveDeleteStateType = "DeleteQueued"
)

// ArchiveDeleteState variant wrappers
type DeleteActiveVariant adtenum.OneVariantValue[DeleteActive]
type DeleteNoneVariant adtenum.OneVariantValue[DeleteNone]
type DeleteQueuedVariant adtenum.OneVariantValue[DeleteQueued]

// ArchiveDeleteState constructors
var NewArchiveDeleteStateDeleteActive = adtenum.CreateOneVariantValueConstructor[DeleteActiveVariant]()
var NewArchiveDeleteStateDeleteNone = adtenum.CreateOneVariantValueConstructor[DeleteNoneVariant]()
var NewArchiveDeleteStateDeleteQueued = adtenum.CreateOneVariantValueConstructor[DeleteQueuedVariant]()

// EnumType methods for ArchiveDeleteState variants
func (v DeleteActiveVariant) EnumType() ArchiveDeleteState { return v }
func (v DeleteNoneVariant) EnumType() ArchiveDeleteState   { return v }
func (v DeleteQueuedVariant) EnumType() ArchiveDeleteState { return v }

// GetArchiveDeleteStateType returns the discriminator type for exhaustive switch checking
func GetArchiveDeleteStateType(enum ArchiveDeleteState) ArchiveDeleteStateType {
	switch enum.(type) {
	case DeleteNoneVariant:
		return ArchiveDeleteStateTypeDeleteNone
	case DeleteQueuedVariant:
		return ArchiveDeleteStateTypeDeleteQueued
	case DeleteActiveVariant:
		return ArchiveDeleteStateTypeDeleteActive
	default:
		assert.Fail("Unhandled ArchiveDeleteState variant in GetArchiveDeleteStateType")
		return ArchiveDeleteStateTypeDeleteActive
	}
}

// ArchiveDeleteStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type ArchiveDeleteStateUnion struct {
	Type ArchiveDeleteStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	DeleteNone   *DeleteNone   `json:"deleteNone,omitempty"`
	DeleteQueued *DeleteQueued `json:"deleteQueued,omitempty"`
	DeleteActive *DeleteActive `json:"deleteActive,omitempty"`
}

// ToArchiveDeleteStateUnion converts an ADT ArchiveDeleteState to an ArchiveDeleteStateUnion
func ToArchiveDeleteStateUnion(r ArchiveDeleteState) ArchiveDeleteStateUnion {
	switch i := r.(type) {
	case DeleteNoneVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:       ArchiveDeleteStateTypeDeleteNone,
			DeleteNone: &data,
		}
	case DeleteQueuedVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteQueued,
			DeleteQueued: &data,
		}
	case DeleteActiveVariant:
		data := i()
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteActive,
			DeleteActive: &data,
		}
	default:
		return ArchiveDeleteStateUnion{
			Type:         ArchiveDeleteStateTypeDeleteActive,
			DeleteActive: &DeleteActive{},
		}
	}
}
