// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package statemachine

import (
	"github.com/chris-tomich/adtenum"
)

// RepositoryStateType is the discriminator enum for RepositoryState
type RepositoryStateType string

const (
	RepositoryStateTypeStateBackingUp RepositoryStateType = "StateBackingUp"
	RepositoryStateTypeStateDeleting RepositoryStateType = "StateDeleting"
	RepositoryStateTypeStateError RepositoryStateType = "StateError"
	RepositoryStateTypeStateIdle RepositoryStateType = "StateIdle"
	RepositoryStateTypeStateMounted RepositoryStateType = "StateMounted"
	RepositoryStateTypeStatePruning RepositoryStateType = "StatePruning"
	RepositoryStateTypeStateQueued RepositoryStateType = "StateQueued"
	RepositoryStateTypeStateRefreshing RepositoryStateType = "StateRefreshing"
)

// RepositoryState variant wrappers
type StateBackingUpVariant adtenum.OneVariantValue[StateBackingUp]
type StateDeletingVariant adtenum.OneVariantValue[StateDeleting]
type StateErrorVariant adtenum.OneVariantValue[StateError]
type StateIdleVariant adtenum.OneVariantValue[StateIdle]
type StateMountedVariant adtenum.OneVariantValue[StateMounted]
type StatePruningVariant adtenum.OneVariantValue[StatePruning]
type StateQueuedVariant adtenum.OneVariantValue[StateQueued]
type StateRefreshingVariant adtenum.OneVariantValue[StateRefreshing]

// RepositoryState constructors
var NewRepositoryStateStateBackingUp = adtenum.CreateOneVariantValueConstructor[StateBackingUpVariant]()
var NewRepositoryStateStateDeleting = adtenum.CreateOneVariantValueConstructor[StateDeletingVariant]()
var NewRepositoryStateStateError = adtenum.CreateOneVariantValueConstructor[StateErrorVariant]()
var NewRepositoryStateStateIdle = adtenum.CreateOneVariantValueConstructor[StateIdleVariant]()
var NewRepositoryStateStateMounted = adtenum.CreateOneVariantValueConstructor[StateMountedVariant]()
var NewRepositoryStateStatePruning = adtenum.CreateOneVariantValueConstructor[StatePruningVariant]()
var NewRepositoryStateStateQueued = adtenum.CreateOneVariantValueConstructor[StateQueuedVariant]()
var NewRepositoryStateStateRefreshing = adtenum.CreateOneVariantValueConstructor[StateRefreshingVariant]()

// EnumType methods for RepositoryState variants
func (v StateBackingUpVariant) EnumType() RepositoryState { return v }
func (v StateDeletingVariant) EnumType() RepositoryState { return v }
func (v StateErrorVariant) EnumType() RepositoryState { return v }
func (v StateIdleVariant) EnumType() RepositoryState { return v }
func (v StateMountedVariant) EnumType() RepositoryState { return v }
func (v StatePruningVariant) EnumType() RepositoryState { return v }
func (v StateQueuedVariant) EnumType() RepositoryState { return v }
func (v StateRefreshingVariant) EnumType() RepositoryState { return v }

// RepositoryStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type RepositoryStateUnion struct {
	Type RepositoryStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	StateIdle *StateIdle `json:"stateIdle,omitempty"`
	StateQueued *StateQueued `json:"stateQueued,omitempty"`
	StateBackingUp *StateBackingUp `json:"stateBackingUp,omitempty"`
	StatePruning *StatePruning `json:"statePruning,omitempty"`
	StateDeleting *StateDeleting `json:"stateDeleting,omitempty"`
	StateRefreshing *StateRefreshing `json:"stateRefreshing,omitempty"`
	StateMounted *StateMounted `json:"stateMounted,omitempty"`
	StateError *StateError `json:"stateError,omitempty"`
}

// ToRepositoryStateUnion converts an ADT RepositoryState to an RepositoryStateUnion
func ToRepositoryStateUnion(r RepositoryState) RepositoryStateUnion {
	switch i := r.(type) {
	case StateIdleVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateIdle,
			StateIdle: &data,
		}
	case StateQueuedVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateQueued,
			StateQueued: &data,
		}
	case StateBackingUpVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateBackingUp,
			StateBackingUp: &data,
		}
	case StatePruningVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStatePruning,
			StatePruning: &data,
		}
	case StateDeletingVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateDeleting,
			StateDeleting: &data,
		}
	case StateRefreshingVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateRefreshing,
			StateRefreshing: &data,
		}
	case StateMountedVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateMounted,
			StateMounted: &data,
		}
	case StateErrorVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateError,
			StateError: &data,
		}
	default:
		return RepositoryStateUnion{
			Type: RepositoryStateTypeStateBackingUp,
			StateBackingUp: &StateBackingUp{},
		}
	}
}

// OperationType is the discriminator enum for Operation
type OperationType string

const (
	OperationTypeOpArchiveDelete OperationType = "OpArchiveDelete"
	OperationTypeOpArchiveRefresh OperationType = "OpArchiveRefresh"
	OperationTypeOpArchiveRename OperationType = "OpArchiveRename"
	OperationTypeOpBackup OperationType = "OpBackup"
	OperationTypeOpDelete OperationType = "OpDelete"
	OperationTypeOpPrune OperationType = "OpPrune"
)

// Operation variant wrappers
type OpArchiveDeleteVariant adtenum.OneVariantValue[OpArchiveDelete]
type OpArchiveRefreshVariant adtenum.OneVariantValue[OpArchiveRefresh]
type OpArchiveRenameVariant adtenum.OneVariantValue[OpArchiveRename]
type OpBackupVariant adtenum.OneVariantValue[OpBackup]
type OpDeleteVariant adtenum.OneVariantValue[OpDelete]
type OpPruneVariant adtenum.OneVariantValue[OpPrune]

// Operation constructors
var NewOperationOpArchiveDelete = adtenum.CreateOneVariantValueConstructor[OpArchiveDeleteVariant]()
var NewOperationOpArchiveRefresh = adtenum.CreateOneVariantValueConstructor[OpArchiveRefreshVariant]()
var NewOperationOpArchiveRename = adtenum.CreateOneVariantValueConstructor[OpArchiveRenameVariant]()
var NewOperationOpBackup = adtenum.CreateOneVariantValueConstructor[OpBackupVariant]()
var NewOperationOpDelete = adtenum.CreateOneVariantValueConstructor[OpDeleteVariant]()
var NewOperationOpPrune = adtenum.CreateOneVariantValueConstructor[OpPruneVariant]()

// EnumType methods for Operation variants
func (v OpArchiveDeleteVariant) EnumType() Operation { return v }
func (v OpArchiveRefreshVariant) EnumType() Operation { return v }
func (v OpArchiveRenameVariant) EnumType() Operation { return v }
func (v OpBackupVariant) EnumType() Operation { return v }
func (v OpDeleteVariant) EnumType() Operation { return v }
func (v OpPruneVariant) EnumType() Operation { return v }

// OperationUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type OperationUnion struct {
	Type OperationType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	OpBackup *OpBackup `json:"opBackup,omitempty"`
	OpPrune *OpPrune `json:"opPrune,omitempty"`
	OpDelete *OpDelete `json:"opDelete,omitempty"`
	OpArchiveRefresh *OpArchiveRefresh `json:"opArchiveRefresh,omitempty"`
	OpArchiveDelete *OpArchiveDelete `json:"opArchiveDelete,omitempty"`
	OpArchiveRename *OpArchiveRename `json:"opArchiveRename,omitempty"`
}

// ToOperationUnion converts an ADT Operation to an OperationUnion
func ToOperationUnion(r Operation) OperationUnion {
	switch i := r.(type) {
	case OpBackupVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpBackup,
			OpBackup: &data,
		}
	case OpPruneVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpPrune,
			OpPrune: &data,
		}
	case OpDeleteVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpDelete,
			OpDelete: &data,
		}
	case OpArchiveRefreshVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpArchiveRefresh,
			OpArchiveRefresh: &data,
		}
	case OpArchiveDeleteVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpArchiveDelete,
			OpArchiveDelete: &data,
		}
	case OpArchiveRenameVariant:
		data := i()
		return OperationUnion{
			Type: OperationTypeOpArchiveRename,
			OpArchiveRename: &data,
		}
	default:
		return OperationUnion{
			Type: OperationTypeOpArchiveDelete,
			OpArchiveDelete: &OpArchiveDelete{},
		}
	}
}

