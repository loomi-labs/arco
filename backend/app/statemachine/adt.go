// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package statemachine

import (
	"github.com/chris-tomich/adtenum"
	"github.com/negrel/assert"
)

// RepositoryStateType is the discriminator enum for RepositoryState
type RepositoryStateType string

const (
	RepositoryStateTypeBackingUp  RepositoryStateType = "BackingUp"
	RepositoryStateTypeDeleting   RepositoryStateType = "Deleting"
	RepositoryStateTypeError      RepositoryStateType = "Error"
	RepositoryStateTypeIdle       RepositoryStateType = "Idle"
	RepositoryStateTypeMounted    RepositoryStateType = "Mounted"
	RepositoryStateTypeMounting   RepositoryStateType = "Mounting"
	RepositoryStateTypePruning    RepositoryStateType = "Pruning"
	RepositoryStateTypeQueued     RepositoryStateType = "Queued"
	RepositoryStateTypeRefreshing RepositoryStateType = "Refreshing"
)

// RepositoryState variant wrappers
type BackingUpVariant adtenum.OneVariantValue[BackingUp]
type DeletingVariant adtenum.OneVariantValue[Deleting]
type ErrorVariant adtenum.OneVariantValue[Error]
type IdleVariant adtenum.OneVariantValue[Idle]
type MountedVariant adtenum.OneVariantValue[Mounted]
type MountingVariant adtenum.OneVariantValue[Mounting]
type PruningVariant adtenum.OneVariantValue[Pruning]
type QueuedVariant adtenum.OneVariantValue[Queued]
type RefreshingVariant adtenum.OneVariantValue[Refreshing]

// RepositoryState constructors
var NewRepositoryStateBackingUp = adtenum.CreateOneVariantValueConstructor[BackingUpVariant]()
var NewRepositoryStateDeleting = adtenum.CreateOneVariantValueConstructor[DeletingVariant]()
var NewRepositoryStateError = adtenum.CreateOneVariantValueConstructor[ErrorVariant]()
var NewRepositoryStateIdle = adtenum.CreateOneVariantValueConstructor[IdleVariant]()
var NewRepositoryStateMounted = adtenum.CreateOneVariantValueConstructor[MountedVariant]()
var NewRepositoryStateMounting = adtenum.CreateOneVariantValueConstructor[MountingVariant]()
var NewRepositoryStatePruning = adtenum.CreateOneVariantValueConstructor[PruningVariant]()
var NewRepositoryStateQueued = adtenum.CreateOneVariantValueConstructor[QueuedVariant]()
var NewRepositoryStateRefreshing = adtenum.CreateOneVariantValueConstructor[RefreshingVariant]()

// EnumType methods for RepositoryState variants
func (v BackingUpVariant) EnumType() RepositoryState  { return v }
func (v DeletingVariant) EnumType() RepositoryState   { return v }
func (v ErrorVariant) EnumType() RepositoryState      { return v }
func (v IdleVariant) EnumType() RepositoryState       { return v }
func (v MountedVariant) EnumType() RepositoryState    { return v }
func (v MountingVariant) EnumType() RepositoryState   { return v }
func (v PruningVariant) EnumType() RepositoryState    { return v }
func (v QueuedVariant) EnumType() RepositoryState     { return v }
func (v RefreshingVariant) EnumType() RepositoryState { return v }

// GetRepositoryStateType returns the discriminator type for exhaustive switch checking
func GetRepositoryStateType(enum RepositoryState) RepositoryStateType {
	switch enum.(type) {
	case IdleVariant:
		return RepositoryStateTypeIdle
	case QueuedVariant:
		return RepositoryStateTypeQueued
	case BackingUpVariant:
		return RepositoryStateTypeBackingUp
	case PruningVariant:
		return RepositoryStateTypePruning
	case DeletingVariant:
		return RepositoryStateTypeDeleting
	case RefreshingVariant:
		return RepositoryStateTypeRefreshing
	case MountingVariant:
		return RepositoryStateTypeMounting
	case MountedVariant:
		return RepositoryStateTypeMounted
	case ErrorVariant:
		return RepositoryStateTypeError
	default:
		assert.Fail("Unhandled RepositoryState variant in GetRepositoryStateType")
		return RepositoryStateTypeBackingUp
	}
}

// RepositoryStateUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type RepositoryStateUnion struct {
	Type RepositoryStateType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Idle       *Idle       `json:"idle,omitempty"`
	Queued     *Queued     `json:"queued,omitempty"`
	BackingUp  *BackingUp  `json:"backingUp,omitempty"`
	Pruning    *Pruning    `json:"pruning,omitempty"`
	Deleting   *Deleting   `json:"deleting,omitempty"`
	Refreshing *Refreshing `json:"refreshing,omitempty"`
	Mounting   *Mounting   `json:"mounting,omitempty"`
	Mounted    *Mounted    `json:"mounted,omitempty"`
	Error      *Error      `json:"error,omitempty"`
}

// ToRepositoryStateUnion converts an ADT RepositoryState to an RepositoryStateUnion
func ToRepositoryStateUnion(r RepositoryState) RepositoryStateUnion {
	switch i := r.(type) {
	case IdleVariant:
		data := i()
		return RepositoryStateUnion{
			Type: RepositoryStateTypeIdle,
			Idle: &data,
		}
	case QueuedVariant:
		data := i()
		return RepositoryStateUnion{
			Type:   RepositoryStateTypeQueued,
			Queued: &data,
		}
	case BackingUpVariant:
		data := i()
		return RepositoryStateUnion{
			Type:      RepositoryStateTypeBackingUp,
			BackingUp: &data,
		}
	case PruningVariant:
		data := i()
		return RepositoryStateUnion{
			Type:    RepositoryStateTypePruning,
			Pruning: &data,
		}
	case DeletingVariant:
		data := i()
		return RepositoryStateUnion{
			Type:     RepositoryStateTypeDeleting,
			Deleting: &data,
		}
	case RefreshingVariant:
		data := i()
		return RepositoryStateUnion{
			Type:       RepositoryStateTypeRefreshing,
			Refreshing: &data,
		}
	case MountingVariant:
		data := i()
		return RepositoryStateUnion{
			Type:     RepositoryStateTypeMounting,
			Mounting: &data,
		}
	case MountedVariant:
		data := i()
		return RepositoryStateUnion{
			Type:    RepositoryStateTypeMounted,
			Mounted: &data,
		}
	case ErrorVariant:
		data := i()
		return RepositoryStateUnion{
			Type:  RepositoryStateTypeError,
			Error: &data,
		}
	default:
		return RepositoryStateUnion{
			Type:      RepositoryStateTypeBackingUp,
			BackingUp: &BackingUp{},
		}
	}
}

// OperationType is the discriminator enum for Operation
type OperationType string

const (
	OperationTypeArchiveDelete  OperationType = "ArchiveDelete"
	OperationTypeArchiveRefresh OperationType = "ArchiveRefresh"
	OperationTypeArchiveRename  OperationType = "ArchiveRename"
	OperationTypeBackup         OperationType = "Backup"
	OperationTypeDelete         OperationType = "Delete"
	OperationTypeExaminePrune   OperationType = "ExaminePrune"
	OperationTypeMount          OperationType = "Mount"
	OperationTypeMountArchive   OperationType = "MountArchive"
	OperationTypePrune          OperationType = "Prune"
	OperationTypeUnmount        OperationType = "Unmount"
	OperationTypeUnmountArchive OperationType = "UnmountArchive"
)

// Operation variant wrappers
type ArchiveDeleteVariant adtenum.OneVariantValue[ArchiveDelete]
type ArchiveRefreshVariant adtenum.OneVariantValue[ArchiveRefresh]
type ArchiveRenameVariant adtenum.OneVariantValue[ArchiveRename]
type BackupVariant adtenum.OneVariantValue[Backup]
type DeleteVariant adtenum.OneVariantValue[Delete]
type ExaminePruneVariant adtenum.OneVariantValue[ExaminePrune]
type MountVariant adtenum.OneVariantValue[Mount]
type MountArchiveVariant adtenum.OneVariantValue[MountArchive]
type PruneVariant adtenum.OneVariantValue[Prune]
type UnmountVariant adtenum.OneVariantValue[Unmount]
type UnmountArchiveVariant adtenum.OneVariantValue[UnmountArchive]

// Operation constructors
var NewOperationArchiveDelete = adtenum.CreateOneVariantValueConstructor[ArchiveDeleteVariant]()
var NewOperationArchiveRefresh = adtenum.CreateOneVariantValueConstructor[ArchiveRefreshVariant]()
var NewOperationArchiveRename = adtenum.CreateOneVariantValueConstructor[ArchiveRenameVariant]()
var NewOperationBackup = adtenum.CreateOneVariantValueConstructor[BackupVariant]()
var NewOperationDelete = adtenum.CreateOneVariantValueConstructor[DeleteVariant]()
var NewOperationExaminePrune = adtenum.CreateOneVariantValueConstructor[ExaminePruneVariant]()
var NewOperationMount = adtenum.CreateOneVariantValueConstructor[MountVariant]()
var NewOperationMountArchive = adtenum.CreateOneVariantValueConstructor[MountArchiveVariant]()
var NewOperationPrune = adtenum.CreateOneVariantValueConstructor[PruneVariant]()
var NewOperationUnmount = adtenum.CreateOneVariantValueConstructor[UnmountVariant]()
var NewOperationUnmountArchive = adtenum.CreateOneVariantValueConstructor[UnmountArchiveVariant]()

// EnumType methods for Operation variants
func (v ArchiveDeleteVariant) EnumType() Operation  { return v }
func (v ArchiveRefreshVariant) EnumType() Operation { return v }
func (v ArchiveRenameVariant) EnumType() Operation  { return v }
func (v BackupVariant) EnumType() Operation         { return v }
func (v DeleteVariant) EnumType() Operation         { return v }
func (v ExaminePruneVariant) EnumType() Operation   { return v }
func (v MountVariant) EnumType() Operation          { return v }
func (v MountArchiveVariant) EnumType() Operation   { return v }
func (v PruneVariant) EnumType() Operation          { return v }
func (v UnmountVariant) EnumType() Operation        { return v }
func (v UnmountArchiveVariant) EnumType() Operation { return v }

// GetOperationType returns the discriminator type for exhaustive switch checking
func GetOperationType(enum Operation) OperationType {
	switch enum.(type) {
	case BackupVariant:
		return OperationTypeBackup
	case PruneVariant:
		return OperationTypePrune
	case DeleteVariant:
		return OperationTypeDelete
	case ArchiveRefreshVariant:
		return OperationTypeArchiveRefresh
	case ArchiveDeleteVariant:
		return OperationTypeArchiveDelete
	case ArchiveRenameVariant:
		return OperationTypeArchiveRename
	case MountVariant:
		return OperationTypeMount
	case MountArchiveVariant:
		return OperationTypeMountArchive
	case UnmountVariant:
		return OperationTypeUnmount
	case UnmountArchiveVariant:
		return OperationTypeUnmountArchive
	case ExaminePruneVariant:
		return OperationTypeExaminePrune
	default:
		assert.Fail("Unhandled Operation variant in GetOperationType")
		return OperationTypeArchiveDelete
	}
}

// OperationUnion is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type OperationUnion struct {
	Type OperationType `json:"type"` // Discriminator field

	// Variant fields - only one will be non-nil
	Backup         *Backup         `json:"backup,omitempty"`
	Prune          *Prune          `json:"prune,omitempty"`
	Delete         *Delete         `json:"delete,omitempty"`
	ArchiveRefresh *ArchiveRefresh `json:"archiveRefresh,omitempty"`
	ArchiveDelete  *ArchiveDelete  `json:"archiveDelete,omitempty"`
	ArchiveRename  *ArchiveRename  `json:"archiveRename,omitempty"`
	Mount          *Mount          `json:"mount,omitempty"`
	MountArchive   *MountArchive   `json:"mountArchive,omitempty"`
	Unmount        *Unmount        `json:"unmount,omitempty"`
	UnmountArchive *UnmountArchive `json:"unmountArchive,omitempty"`
	ExaminePrune   *ExaminePrune   `json:"examinePrune,omitempty"`
}

// ToOperationUnion converts an ADT Operation to an OperationUnion
func ToOperationUnion(r Operation) OperationUnion {
	switch i := r.(type) {
	case BackupVariant:
		data := i()
		return OperationUnion{
			Type:   OperationTypeBackup,
			Backup: &data,
		}
	case PruneVariant:
		data := i()
		return OperationUnion{
			Type:  OperationTypePrune,
			Prune: &data,
		}
	case DeleteVariant:
		data := i()
		return OperationUnion{
			Type:   OperationTypeDelete,
			Delete: &data,
		}
	case ArchiveRefreshVariant:
		data := i()
		return OperationUnion{
			Type:           OperationTypeArchiveRefresh,
			ArchiveRefresh: &data,
		}
	case ArchiveDeleteVariant:
		data := i()
		return OperationUnion{
			Type:          OperationTypeArchiveDelete,
			ArchiveDelete: &data,
		}
	case ArchiveRenameVariant:
		data := i()
		return OperationUnion{
			Type:          OperationTypeArchiveRename,
			ArchiveRename: &data,
		}
	case MountVariant:
		data := i()
		return OperationUnion{
			Type:  OperationTypeMount,
			Mount: &data,
		}
	case MountArchiveVariant:
		data := i()
		return OperationUnion{
			Type:         OperationTypeMountArchive,
			MountArchive: &data,
		}
	case UnmountVariant:
		data := i()
		return OperationUnion{
			Type:    OperationTypeUnmount,
			Unmount: &data,
		}
	case UnmountArchiveVariant:
		data := i()
		return OperationUnion{
			Type:           OperationTypeUnmountArchive,
			UnmountArchive: &data,
		}
	case ExaminePruneVariant:
		data := i()
		return OperationUnion{
			Type:         OperationTypeExaminePrune,
			ExaminePrune: &data,
		}
	default:
		return OperationUnion{
			Type:          OperationTypeArchiveDelete,
			ArchiveDelete: &ArchiveDelete{},
		}
	}
}
