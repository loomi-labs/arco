//go:build ignore

// Code generator for ADT (Algebraic Data Type) boilerplate
// Generates variant wrappers, constructors, and EnumType methods for adtenum.Enum types

package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// Configuration constants
const (
	// Module and file configuration
	ModulePath        = "github.com/loomi-labs/arco/"
	GeneratedFileName = "adt.go"
	FilePermissions   = 0644

	// ADT detection
	MarkerMethodName = "isADTVariant"
	AdtEnumImport    = "github.com/chris-tomich/adtenum"

	// JSON tag configuration
	TypeFieldTag = "type"
	OmitEmptyTag = "omitempty"

	// Directory scanning
	BackendRootDir  = "./backend"
	TestSuffix      = "_test"
	HiddenDirPrefix = "."

	// Code generation naming patterns
	VariantSuffix     = "Variant"
	UnionSuffix       = "Union"
	TypeSuffix        = "Type"
	ConstructorPrefix = "New"
	ConversionPrefix  = "To"
)

// Code generation templates
var (
	// File header template for generated adt.go files
	FileHeaderTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package %s

import (
	"` + AdtEnumImport + `"
	"github.com/negrel/assert"
)

`

	// Discriminator enum type and constants template
	DiscriminatorTypeTemplate = `// %s is the discriminator enum for %s
type %s string

const (
%s)

`

	// Variant wrappers section template
	VariantWrapperTemplate = `// %s variant wrappers
%s
`

	// Constructors section template
	ConstructorTemplate = `// %s constructors
%s
`

	// EnumType methods section template
	EnumMethodTemplate = `// EnumType methods for %s variants
%s
`

	// Type function template for exhaustive checking
	TypeFunctionTemplate = `// Get%sType returns the discriminator type for exhaustive switch checking
func Get%sType(enum %s) %s {
	switch enum.(type) {
%s	default:
		assert.Fail("Unhandled %s variant in Get%sType")
		return %s
	}
}

`

	// Union struct template
	UnionStructTemplate = `// %s is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type %s struct {
	Type %s ` + "`json:\"" + TypeFieldTag + "\"`" + ` // Discriminator field

	// Variant fields - only one will be non-nil
%s}

`

	// Conversion function template
	ConversionFunctionTemplate = `// %s converts an ADT %s to an %s
func %s(r %s) %s {
	switch i := r.(type) {
%s	default:
		return %s{
			Type: %s,
			%s: &%s{},
		}
	}
}

`
)

type PackageInfo struct {
	Name  string     // Package name (e.g., "statemachine")
	Path  string     // Package path (e.g., "backend/app/statemachine")
	Enums []EnumInfo // ADT enums found in this package
}

type EnumInfo struct {
	Name         string        // e.g., "RepositoryState", "Operation"
	Variants     []string      // e.g., ["Idle", "BackingUp", "Pruning"]
	StateStructs []StateStruct // State data structs for this enum
}

type StateStruct struct {
	Name      string // e.g., "StateIdle", "StateBackingUp"
	Variant   string // e.g., "Idle", "BackingUp"
	JsonField string // e.g., "idle", "backingUp"
}

// findBackendDir locates the backend directory relative to current working directory
func findBackendDir() (string, error) {
	return findBackendDirRecursive(".", 10)
}

// findBackendDirRecursive searches for backend directory recursively up the directory tree
func findBackendDirRecursive(currentPath string, maxLevels int) (string, error) {
	if maxLevels <= 0 {
		return "", fmt.Errorf("could not find backend directory within %d levels", 10)
	}

	backendPath := filepath.Join(currentPath, "backend")
	if _, err := os.Stat(backendPath); err == nil {
		return backendPath, nil
	}

	// Try one level up
	parentPath := filepath.Join(currentPath, "..")
	return findBackendDirRecursive(parentPath, maxLevels-1)
}

func main() {
	// Find the backend directory from current working directory
	backendDir, err := findBackendDir()
	if err != nil {
		panic(err)
	}

	// Scan for packages containing ADT enums
	packages, err := findPackagesWithAdtEnums(backendDir)
	if err != nil {
		panic(err)
	}

	if len(packages) == 0 {
		fmt.Println("No packages with ADT types found")
		return
	}

	// Debug output removed for cleaner generation

	// Generate consolidated adt.go files for each package
	for _, pkg := range packages {
		if len(pkg.Enums) > 0 {
			generateAdtSubpackage(pkg)
		}
	}
}

func findPackagesWithAdtEnums(rootDir string) ([]PackageInfo, error) {
	var packages []PackageInfo

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip non-directories and hidden directories
		if !info.IsDir() || strings.HasPrefix(info.Name(), HiddenDirPrefix) {
			return nil
		}

		// Try to parse this directory as a Go package
		fset := token.NewFileSet()
		pkgs, parseErr := parser.ParseDir(fset, path, nil, parser.ParseComments)
		if parseErr != nil {
			// Not a valid Go package, skip
			return nil
		}

		// Check each package in this directory
		for pkgName, _ := range pkgs {
			// Skip test packages
			if strings.HasSuffix(pkgName, TestSuffix) {
				continue
			}

			// Find ADT enums by looking for isADTVariant methods
			foundEnums := findAdtEnumsByMarkerMethods(path)

			if len(foundEnums) > 0 {
				packages = append(packages, PackageInfo{
					Name:  pkgName,
					Path:  path,
					Enums: foundEnums,
				})
			}
		}

		return nil
	})

	return packages, err
}

func generateAdtSubpackage(pkg PackageInfo) {
	// Generate consolidated adt.go file with all ADT code in the same package
	output := fmt.Sprintf(FileHeaderTemplate, pkg.Name)

	// Generate all code grouped by enum type
	for _, enum := range pkg.Enums {
		// Generate enum discriminator type and constants
		enumTypeName := enum.Name + TypeSuffix

		var constants string
		for _, variant := range enum.Variants {
			constName := enumTypeName + variant
			constants += fmt.Sprintf("\t%s %s = \"%s\"\n", constName, enumTypeName, variant)
		}

		output += fmt.Sprintf(DiscriminatorTypeTemplate, enumTypeName, enum.Name, enumTypeName, constants)

		// Generate variant type definitions using discovered state structs
		var variantWrappers string
		for _, variant := range enum.Variants {
			variantTypeName := variant + VariantSuffix
			stateStructName := "struct{}"

			// Find the matching state struct from the discovered structs
			for _, state := range enum.StateStructs {
				if state.Variant == variant {
					// Use unqualified name for structs in same package
					stateStructName = state.Name
					break
				}
			}

			variantWrappers += fmt.Sprintf("type %s adtenum.OneVariantValue[%s]\n", variantTypeName, stateStructName)
		}

		output += fmt.Sprintf(VariantWrapperTemplate, enum.Name, variantWrappers)

		// Generate constructors
		var constructors string
		for _, variant := range enum.Variants {
			variantTypeName := variant + VariantSuffix
			constructorName := ConstructorPrefix + enum.Name + variant
			constructors += fmt.Sprintf("var %s = adtenum.CreateOneVariantValueConstructor[%s]()\n", constructorName, variantTypeName)
		}

		output += fmt.Sprintf(ConstructorTemplate, enum.Name, constructors)

		// Generate EnumType methods
		var enumMethods string
		for _, variant := range enum.Variants {
			variantTypeName := variant + VariantSuffix
			enumMethods += fmt.Sprintf("func (v %s) EnumType() %s { return v }\n", variantTypeName, enum.Name)
		}

		output += fmt.Sprintf(EnumMethodTemplate, enum.Name, enumMethods)

		// Generate Type function for exhaustive checking
		output += generateTypeFunction(enum)

		// Generate Union type and conversion function
		output += generateUnionType(enum)
		output += generateFromConversion(enum)
	}

	// Format the generated code
	formattedOutput, err := format.Source([]byte(output))
	if err != nil {
		fmt.Printf("Warning: Failed to format generated code for package %s: %v\n", pkg.Name, err)
		fmt.Println("Writing unformatted code...")
		formattedOutput = []byte(output)
	}

	// Write to the package directory
	outputPath := filepath.Join(pkg.Path, GeneratedFileName)
	err = os.WriteFile(outputPath, formattedOutput, FilePermissions)
	if err != nil {
		panic(err)
	}

	enumNames := getEnumNames(pkg.Enums)
	fmt.Printf("Generated consolidated ADT file for package %s: %v\n", pkg.Name, enumNames)
}

// findAdtEnumsByMarkerMethods finds ADTs by looking for isADTVariant method implementations
func findAdtEnumsByMarkerMethods(packagePath string) []EnumInfo {
	var enums []EnumInfo
	enumToStructsMap := make(map[string][]StateStruct)

	// Parse the package to find isADTVariant methods
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
	if err != nil {
		return enums
	}

	// First pass: find all isADTVariant methods and group by return type
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok {
					continue
				}

				// Look for methods named "isADTVariant"
				if funcDecl.Name.Name != MarkerMethodName {
					continue
				}

				// Check if it has a receiver (method)
				if funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
					continue
				}

				// Extract receiver type
				recv := funcDecl.Recv.List[0]
				var receiverTypeName string

				switch recvType := recv.Type.(type) {
				case *ast.Ident:
					receiverTypeName = recvType.Name
				default:
					continue
				}

				// Check if the method returns an ADT type
				if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) == 0 {
					continue
				}

				result := funcDecl.Type.Results.List[0]
				var returnTypeName string

				switch resultType := result.Type.(type) {
				case *ast.Ident:
					returnTypeName = resultType.Name
				default:
					continue
				}

				// Collect all struct names for this ADT (we'll extract variant names later)
				if _, exists := enumToStructsMap[returnTypeName]; !exists {
					enumToStructsMap[returnTypeName] = []StateStruct{}
				}
				enumToStructsMap[returnTypeName] = append(enumToStructsMap[returnTypeName], StateStruct{
					Name:    receiverTypeName,
					Variant: "", // Will be filled in the second pass
				})
			}
		}
	}

	// Second pass: extract variant names using generic algorithm and create EnumInfo
	for enumName, stateStructs := range enumToStructsMap {
		if len(stateStructs) > 0 {
			// Get all struct names for this ADT
			var structNames []string
			for _, state := range stateStructs {
				structNames = append(structNames, state.Name)
			}

			// Use struct names directly as variant names
			var variants []string
			for i, state := range stateStructs {
				variantName := state.Name // Use struct name directly
				stateStructs[i].Variant = variantName
				stateStructs[i].JsonField = variantToJsonField(variantName)
				variants = append(variants, variantName)
			}

			if len(variants) > 0 {
				sort.Strings(variants)

				enums = append(enums, EnumInfo{
					Name:         enumName,
					Variants:     variants,
					StateStructs: stateStructs,
				})
			}
		}
	}

	return enums
}

// getPackageImportPath converts a file path to a Go import path
func getPackageImportPath(packagePath string) string {
	// Convert from file path to Go import path
	// e.g., "./backend/app/statemachine" -> "github.com/loomi-labs/arco/backend/app/statemachine"
	cleanPath := strings.TrimPrefix(packagePath, "./")
	cleanPath = strings.TrimPrefix(cleanPath, "/")
	return ModulePath + cleanPath
}

// variantToJsonField converts a variant name to camelCase JSON field name
// e.g., "BackingUp" -> "backingUp", "ArchiveRefresh" -> "archiveRefresh", "Idle" -> "idle"
func variantToJsonField(variant string) string {
	if len(variant) == 0 {
		return variant
	}

	runes := []rune(variant)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

// getDefaultVariant returns the first variant (alphabetically) to use as default
func getDefaultVariant(variants []string) string {
	if len(variants) == 0 {
		return ""
	}

	// Return the first variant since they're already sorted
	return variants[0]
}

func getEnumNames(enums []EnumInfo) []string {
	var names []string
	for _, enum := range enums {
		names = append(names, enum.Name)
	}
	return names
}

// generateUnionType generates the Union struct definition for an ADT enum
func generateUnionType(enum EnumInfo) string {
	enumTypeName := enum.Name + TypeSuffix
	unionTypeName := enum.Name + UnionSuffix

	// Build variant fields string
	var variantFields string
	for _, state := range enum.StateStructs {
		if state.Variant != "" {
			variantFields += fmt.Sprintf("\t%s *%s `json:\"%s,%s\"`\n", state.Variant, state.Name, state.JsonField, OmitEmptyTag)
		}
	}

	return fmt.Sprintf(UnionStructTemplate, unionTypeName, unionTypeName, enumTypeName, variantFields)
}

// generateFromConversion generates the To{EnumName}Union function that converts ADT to Union
func generateFromConversion(enum EnumInfo) string {
	unionTypeName := enum.Name + UnionSuffix
	enumTypeName := enum.Name + TypeSuffix
	functionName := ConversionPrefix + enum.Name + UnionSuffix
	defaultVariant := getDefaultVariant(enum.Variants)

	// Build switch cases string
	var switchCases string
	for _, state := range enum.StateStructs {
		if state.Variant != "" {
			variantTypeName := state.Variant + VariantSuffix
			enumConstant := enumTypeName + state.Variant
			switchCases += fmt.Sprintf("\tcase %s:\n", variantTypeName)
			switchCases += "\t\tdata := i()\n"
			switchCases += fmt.Sprintf("\t\treturn %s{\n", unionTypeName)
			switchCases += fmt.Sprintf("\t\t\tType: %s,\n", enumConstant)
			switchCases += fmt.Sprintf("\t\t\t%s: &data,\n", state.Variant)
			switchCases += "\t\t}\n"
		}
	}

	// Build default case parameters
	var defaultEnumConstant, defaultStateStruct string
	if defaultVariant != "" {
		defaultEnumConstant = enumTypeName + defaultVariant
		for _, state := range enum.StateStructs {
			if state.Variant == defaultVariant {
				defaultStateStruct = state.Name
				break
			}
		}
	}

	return fmt.Sprintf(ConversionFunctionTemplate,
		functionName, enum.Name, unionTypeName, // Comment and function signature
		functionName, enum.Name, unionTypeName, // Function declaration
		switchCases,                        // Switch cases
		unionTypeName, defaultEnumConstant, // Default case return struct
		defaultVariant, defaultStateStruct) // Default case field assignment
}

// generateTypeFunction generates the Get{Name}Type function for exhaustive switch checking
func generateTypeFunction(enum EnumInfo) string {
	enumTypeName := enum.Name + TypeSuffix
	defaultVariant := getDefaultVariant(enum.Variants)
	defaultEnumConstant := enumTypeName + defaultVariant

	// Build switch cases string
	var switchCases string
	for _, state := range enum.StateStructs {
		if state.Variant != "" {
			variantTypeName := state.Variant + VariantSuffix
			enumConstant := enumTypeName + state.Variant
			switchCases += fmt.Sprintf("\tcase %s:\n", variantTypeName)
			switchCases += fmt.Sprintf("\t\treturn %s\n", enumConstant)
		}
	}

	return fmt.Sprintf(TypeFunctionTemplate,
		enum.Name, enum.Name, enum.Name, enumTypeName, // Function name and signature
		switchCases,          // Switch cases
		enum.Name, enum.Name, // Assert message parameters
		defaultEnumConstant) // Default case
}
