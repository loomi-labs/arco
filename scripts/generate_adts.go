//go:build ignore

// Code generator for ADT (Algebraic Data Type) boilerplate
// Generates variant wrappers, constructors, and EnumType methods for adtenum.Enum types

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// Configuration constants
const (
	// Module and file configuration
	ModulePath        = "github.com/loomi-labs/arco/"
	GeneratedFileName = "adt.go"
	FilePermissions   = 0644

	// ADT detection
	MarkerMethodName = "isADTVariant"
	AdtEnumImport    = "github.com/chris-tomich/adtenum"

	// JSON tag configuration
	TypeFieldTag = "type"
	OmitEmptyTag = "omitempty"

	// Directory scanning
	BackendRootDir  = "./backend"
	TestSuffix      = "_test"
	HiddenDirPrefix = "."
)

// Configurable variables
var (
	// Common struct name patterns for variant detection
	CommonStructPrefixes = []string{"State", "Op", "Status", "Event", "Action"}
)

// Code generation templates
var (
	// File header template for generated adt.go files
	FileHeaderTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated ADT boilerplate and enums for adtenum.Enum types

package %s

import (
	"` + AdtEnumImport + `"
)

`

	// Discriminator enum type and constants template
	DiscriminatorTypeTemplate = `// %s is the discriminator enum for %s
type %s string

const (
%s)

`

	// Variant wrappers section template
	VariantWrapperTemplate = `// %s variant wrappers
%s
`

	// Constructors section template
	ConstructorTemplate = `// %s constructors
%s
`

	// EnumType methods section template
	EnumMethodTemplate = `// EnumType methods for %s variants
%s
`

	// Union struct template
	UnionStructTemplate = `// %s is a concrete struct that Wails3 can serialize to TypeScript discriminated unions
type %s struct {
	Type %s ` + "`json:\"" + TypeFieldTag + "\"`" + ` // Discriminator field

	// Variant fields - only one will be non-nil
%s}

`

	// Conversion function template
	ConversionFunctionTemplate = `// %s converts an ADT %s to an %s
func %s(r %s) %s {
	switch i := r.(type) {
%s	default:
		return %s{
			Type: %s,
			%s: &%s{},
		}
	}
}

`
)

type PackageInfo struct {
	Name  string     // Package name (e.g., "statemachine")
	Path  string     // Package path (e.g., "backend/app/statemachine")
	Enums []EnumInfo // ADT enums found in this package
}

type EnumInfo struct {
	Name         string        // e.g., "RepositoryState", "Operation"
	Variants     []string      // e.g., ["Idle", "BackingUp", "Pruning"]
	StateStructs []StateStruct // State data structs for this enum
}

type StateStruct struct {
	Name      string // e.g., "StateIdle", "StateBackingUp"
	Variant   string // e.g., "Idle", "BackingUp"
	JsonField string // e.g., "idle", "backingUp"
}

func main() {
	// Scan for packages containing ADT enums
	packages, err := findPackagesWithAdtEnums(BackendRootDir)
	if err != nil {
		panic(err)
	}

	if len(packages) == 0 {
		fmt.Println("No packages with ADT types found")
		return
	}

	// Debug output removed for cleaner generation

	// Generate consolidated adt.go files for each package
	for _, pkg := range packages {
		if len(pkg.Enums) > 0 {
			generateAdtSubpackage(pkg)
		}
	}
}

func findPackagesWithAdtEnums(rootDir string) ([]PackageInfo, error) {
	var packages []PackageInfo

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip non-directories and hidden directories
		if !info.IsDir() || strings.HasPrefix(info.Name(), HiddenDirPrefix) {
			return nil
		}

		// Try to parse this directory as a Go package
		fset := token.NewFileSet()
		pkgs, parseErr := parser.ParseDir(fset, path, nil, parser.ParseComments)
		if parseErr != nil {
			// Not a valid Go package, skip
			return nil
		}

		// Check each package in this directory
		for pkgName, _ := range pkgs {
			// Skip test packages
			if strings.HasSuffix(pkgName, TestSuffix) {
				continue
			}

			// Find ADT enums by looking for isADTVariant methods
			foundEnums := findAdtEnumsByMarkerMethods(path)

			if len(foundEnums) > 0 {
				packages = append(packages, PackageInfo{
					Name:  pkgName,
					Path:  path,
					Enums: foundEnums,
				})
			}
		}

		return nil
	})

	return packages, err
}

func generateAdtSubpackage(pkg PackageInfo) {
	// Generate consolidated adt.go file with all ADT code in the same package
	output := fmt.Sprintf(FileHeaderTemplate, pkg.Name)

	// Generate all code grouped by enum type
	for _, enum := range pkg.Enums {
		// Generate enum discriminator type and constants
		enumTypeName := enum.Name + "Type"

		var constants string
		for _, variant := range enum.Variants {
			constName := enumTypeName + variant
			constants += fmt.Sprintf("\t%s %s = \"%s\"\n", constName, enumTypeName, variant)
		}

		output += fmt.Sprintf(DiscriminatorTypeTemplate, enumTypeName, enum.Name, enumTypeName, constants)

		// Generate variant type definitions using discovered state structs
		var variantWrappers string
		for _, variant := range enum.Variants {
			variantTypeName := variant + "Variant"
			stateStructName := "struct{}"

			// Find the matching state struct from the discovered structs
			for _, state := range enum.StateStructs {
				if state.Variant == variant {
					// Use unqualified name for structs in same package
					stateStructName = state.Name
					break
				}
			}

			variantWrappers += fmt.Sprintf("type %s adtenum.OneVariantValue[%s]\n", variantTypeName, stateStructName)
		}

		output += fmt.Sprintf(VariantWrapperTemplate, enum.Name, variantWrappers)

		// Generate constructors
		var constructors string
		for _, variant := range enum.Variants {
			variantTypeName := variant + "Variant"
			constructorName := "New" + enum.Name + variant
			constructors += fmt.Sprintf("var %s = adtenum.CreateOneVariantValueConstructor[%s]()\n", constructorName, variantTypeName)
		}

		output += fmt.Sprintf(ConstructorTemplate, enum.Name, constructors)

		// Generate EnumType methods
		var enumMethods string
		for _, variant := range enum.Variants {
			variantTypeName := variant + "Variant"
			enumMethods += fmt.Sprintf("func (v %s) EnumType() %s { return v }\n", variantTypeName, enum.Name)
		}

		output += fmt.Sprintf(EnumMethodTemplate, enum.Name, enumMethods)

		// Generate Union type and conversion function
		output += generateUnionType(enum)
		output += generateFromConversion(enum)
	}

	// Write to the package directory
	outputPath := filepath.Join(pkg.Path, GeneratedFileName)
	err := os.WriteFile(outputPath, []byte(output), FilePermissions)
	if err != nil {
		panic(err)
	}

	enumNames := getEnumNames(pkg.Enums)
	fmt.Printf("Generated consolidated ADT file for package %s: %v\n", pkg.Name, enumNames)
}

// findAdtEnumsByMarkerMethods finds ADTs by looking for isADTVariant method implementations
func findAdtEnumsByMarkerMethods(packagePath string) []EnumInfo {
	var enums []EnumInfo
	enumToStructsMap := make(map[string][]StateStruct)

	// Parse the package to find isADTVariant methods
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
	if err != nil {
		return enums
	}

	// First pass: find all isADTVariant methods and group by return type
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok {
					continue
				}

				// Look for methods named "isADTVariant"
				if funcDecl.Name.Name != MarkerMethodName {
					continue
				}

				// Check if it has a receiver (method)
				if funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
					continue
				}

				// Extract receiver type
				recv := funcDecl.Recv.List[0]
				var receiverTypeName string

				switch recvType := recv.Type.(type) {
				case *ast.Ident:
					receiverTypeName = recvType.Name
				default:
					continue
				}

				// Check if the method returns an ADT type
				if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) == 0 {
					continue
				}

				result := funcDecl.Type.Results.List[0]
				var returnTypeName string

				switch resultType := result.Type.(type) {
				case *ast.Ident:
					returnTypeName = resultType.Name
				default:
					continue
				}

				// Collect all struct names for this ADT (we'll extract variant names later)
				if _, exists := enumToStructsMap[returnTypeName]; !exists {
					enumToStructsMap[returnTypeName] = []StateStruct{}
				}
				enumToStructsMap[returnTypeName] = append(enumToStructsMap[returnTypeName], StateStruct{
					Name:    receiverTypeName,
					Variant: "", // Will be filled in the second pass
				})
			}
		}
	}

	// Second pass: extract variant names using generic algorithm and create EnumInfo
	for enumName, stateStructs := range enumToStructsMap {
		if len(stateStructs) > 0 {
			// Get all struct names for this ADT
			var structNames []string
			for _, state := range stateStructs {
				structNames = append(structNames, state.Name)
			}

			// Extract variant names using generic algorithm
			var variants []string
			for i, state := range stateStructs {
				variantName := extractVariantNameGeneric(state.Name, structNames)
				if variantName != "" {
					stateStructs[i].Variant = variantName
					stateStructs[i].JsonField = variantToJsonField(variantName)
					variants = append(variants, variantName)
				}
			}

			if len(variants) > 0 {
				sort.Strings(variants)

				enums = append(enums, EnumInfo{
					Name:         enumName,
					Variants:     variants,
					StateStructs: stateStructs,
				})
			}
		}
	}

	return enums
}

// extractVariantNameGeneric extracts the variant name from a struct name using generic pattern detection
func extractVariantNameGeneric(structName string, allStructsForADT []string) string {
	// Find the longest common prefix among all structs for this ADT
	commonPrefix := findLongestCommonPrefix(allStructsForADT)

	// Remove the common prefix to get the variant name
	if commonPrefix != "" && strings.HasPrefix(structName, commonPrefix) {
		variant := strings.TrimPrefix(structName, commonPrefix)
		if variant != "" && variant != structName {
			return variant
		}
	}

	// Fallback: try common naming patterns
	for _, prefix := range CommonStructPrefixes {
		if strings.HasPrefix(structName, prefix) {
			variant := strings.TrimPrefix(structName, prefix)
			if variant != "" && variant != structName {
				return variant
			}
		}
	}

	return ""
}

// findLongestCommonPrefix finds the longest common prefix among a slice of strings
func findLongestCommonPrefix(strings []string) string {
	if len(strings) == 0 {
		return ""
	}
	if len(strings) == 1 {
		return ""
	}

	// Start with the first string as the candidate prefix
	prefix := strings[0]

	// Compare with all other strings and reduce the prefix
	for i := 1; i < len(strings); i++ {
		prefix = commonPrefix(prefix, strings[i])
		if prefix == "" {
			break
		}
	}

	return prefix
}

// commonPrefix finds the common prefix between two strings
func commonPrefix(a, b string) string {
	minLen := len(a)
	if len(b) < minLen {
		minLen = len(b)
	}

	for i := 0; i < minLen; i++ {
		if a[i] != b[i] {
			return a[:i]
		}
	}

	return a[:minLen]
}

// getPackageImportPath converts a file path to a Go import path
func getPackageImportPath(packagePath string) string {
	// Convert from file path to Go import path
	// e.g., "./backend/app/statemachine" -> "github.com/loomi-labs/arco/backend/app/statemachine"
	cleanPath := strings.TrimPrefix(packagePath, "./")
	cleanPath = strings.TrimPrefix(cleanPath, "/")
	return ModulePath + cleanPath
}

// variantToJsonField converts a variant name to camelCase JSON field name
// e.g., "BackingUp" -> "backingUp", "ArchiveRefresh" -> "archiveRefresh", "Idle" -> "idle"
func variantToJsonField(variant string) string {
	if len(variant) == 0 {
		return variant
	}

	runes := []rune(variant)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}

// getDefaultVariant returns the first variant (alphabetically) to use as default
func getDefaultVariant(variants []string) string {
	if len(variants) == 0 {
		return ""
	}

	// Return the first variant since they're already sorted
	return variants[0]
}

func getEnumNames(enums []EnumInfo) []string {
	var names []string
	for _, enum := range enums {
		names = append(names, enum.Name)
	}
	return names
}

// generateUnionType generates the Union struct definition for an ADT enum
func generateUnionType(enum EnumInfo) string {
	enumTypeName := enum.Name + "Type"
	unionTypeName := enum.Name + "Union"

	// Build variant fields string
	var variantFields string
	for _, state := range enum.StateStructs {
		if state.Variant != "" {
			variantFields += fmt.Sprintf("\t%s *%s `json:\"%s,%s\"`\n", state.Variant, state.Name, state.JsonField, OmitEmptyTag)
		}
	}

	return fmt.Sprintf(UnionStructTemplate, unionTypeName, unionTypeName, enumTypeName, variantFields)
}

// generateFromConversion generates the To{EnumName}Union function that converts ADT to Union
func generateFromConversion(enum EnumInfo) string {
	unionTypeName := enum.Name + "Union"
	enumTypeName := enum.Name + "Type"
	functionName := "To" + enum.Name + "Union"
	defaultVariant := getDefaultVariant(enum.Variants)

	// Build switch cases string
	var switchCases string
	for _, state := range enum.StateStructs {
		if state.Variant != "" {
			variantTypeName := state.Variant + "Variant"
			enumConstant := enumTypeName + state.Variant
			switchCases += fmt.Sprintf("\tcase %s:\n", variantTypeName)
			switchCases += "\t\tdata := i()\n"
			switchCases += fmt.Sprintf("\t\treturn %s{\n", unionTypeName)
			switchCases += fmt.Sprintf("\t\t\tType: %s,\n", enumConstant)
			switchCases += fmt.Sprintf("\t\t\t%s: &data,\n", state.Variant)
			switchCases += "\t\t}\n"
		}
	}

	// Build default case parameters
	var defaultEnumConstant, defaultStateStruct string
	if defaultVariant != "" {
		defaultEnumConstant = enumTypeName + defaultVariant
		for _, state := range enum.StateStructs {
			if state.Variant == defaultVariant {
				defaultStateStruct = state.Name
				break
			}
		}
	}

	return fmt.Sprintf(ConversionFunctionTemplate,
		functionName, enum.Name, unionTypeName, // Comment and function signature
		functionName, enum.Name, unionTypeName, // Function declaration
		switchCases,                        // Switch cases
		unionTypeName, defaultEnumConstant, // Default case return struct
		defaultVariant, defaultStateStruct) // Default case field assignment
}
