name: Build Application

on:
  workflow_call:
    inputs:
      push_artifacts:
        description: 'Whether to push artifacts to releases'
        type: boolean
        required: false
        default: false
      version:
        description: 'Version tag for the build (e.g., v1.1.0)'
        required: false
        type: string
    outputs:
      artifacts:
        description: 'List of built artifacts'
        value: ${{ jobs.build.outputs.artifacts }}

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        # Build Arco for Linux and MacOS
        build: [
          { zip-name: arco-linux, platform: linux/amd64, os: ubuntu-latest },
          { zip-name: arco-macos, platform: darwin/universal, os: macos-latest }
        ]
    runs-on: ${{ matrix.build.os }}
    outputs:
      artifacts: ${{ steps.artifacts.outputs.list }}
    steps:
      # Checkout the repository
      - name: Checkout repo
        uses: actions/checkout@v4

      # Validate version for release builds
      - name: Validate version for release
        if: inputs.push_artifacts == true
        run: |
          VERSION="${{ inputs.version }}"

          # Check if version is empty
          if [ -z "$VERSION" ]; then
            echo "::error::VERSION is required for release builds but was not provided"
            echo "inputs.version: '${{ inputs.version }}'"
            exit 1
          fi

          # Check if version is 'dev'
          if [ "$VERSION" = "dev" ]; then
            echo "::error::VERSION cannot be 'dev' for release builds"
            echo "inputs.version: '$VERSION'"
            exit 1
          fi

          # Check if version is v0.0.0
          if [ "$VERSION" = "v0.0.0" ]; then
            echo "::error::VERSION cannot be 'v0.0.0' for release builds"
            echo "inputs.version: '$VERSION'"
            exit 1
          fi

          # Validate version format (should start with 'v' and contain digits)
          if ! [[ "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            echo "::error::VERSION must be in format 'vX.Y.Z' (e.g., v1.2.3)"
            echo "inputs.version: '$VERSION'"
            exit 1
          fi

          echo "âœ… Version validation passed: $VERSION"

      - name: Check for relevant changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            build:
              - 'backend/**'
              - 'frontend/**'
              - 'build/**'
              - 'go.mod'
              - 'go.sum'
              - 'package.json'
              - 'Taskfile*.yml'
              - '.github/workflows/build.yml'

      - name: Check if build should run
        id: should-build
        run: |
          # Always build if artifacts should be pushed (release scenario)
          if [ "${{ inputs.push_artifacts }}" = "true" ]; then
            echo "reason=release" >> $GITHUB_OUTPUT
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "Build required: Release artifacts needed"
          # Build if relevant files changed
          elif [ "${{ steps.changes.outputs.build }}" = "true" ]; then
            echo "reason=changes" >> $GITHUB_OUTPUT
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "Build required: Relevant files changed"
          # Skip build
          else
            echo "reason=skip" >> $GITHUB_OUTPUT
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Build skipped: No relevant changes and no release"
          fi

      # Setup Golang
      - name: ðŸ¿ Setup Golang
        if: steps.should-build.outputs.should_run == 'true'
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      # Install task
      - name: Install Task
        if: steps.should-build.outputs.should_run == 'true'
        uses: arduino/setup-task@v2
        with:
          version: 3.x
          repo-token: ${{ secrets.GITHUB_TOKEN }}
      # Install pnpm
      - name: Install pnpm
        if: steps.should-build.outputs.should_run == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: 10
      # Install Wails deps
      - name: Install Linux Wails deps
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'Linux'
        run: sudo apt-get update && sudo apt-get install libgtk-3-0 libwebkit2gtk-4.1-dev gcc-aarch64-linux-gnu jq
        shell: bash
      - name: Install macOS Wails deps
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'macOS'
        run: brew install create-dmg jq
        shell: bash

      # Building step
      - name: Build App
        if: steps.should-build.outputs.should_run == 'true'
        run: task build PRODUCTION=true
        shell: bash
        env:
          PLATFORM: ${{ matrix.build.platform }}
          VERSION: ${{ inputs.version || 'dev' }}

      - name: Add execute permissions
        if: steps.should-build.outputs.should_run == 'true'
        run: chmod +x bin/*
        shell: bash

      # Package macOS .app bundle
      - name: Create macOS .app bundle
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'macOS'
        run: task darwin:create:app:bundle
        shell: bash

      # Download macFUSE for PKG installer
      - name: Download macFUSE
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'macOS'
        run: |
          mkdir -p build/darwin/resources
          curl -L https://github.com/macfuse/macfuse/releases/download/macfuse-5.1.2/macfuse-5.1.2.dmg -o /tmp/macfuse.dmg
          hdiutil attach /tmp/macfuse.dmg -mountpoint /tmp/macfuse-mount
          cp "/tmp/macfuse-mount/Install macFUSE.pkg" build/darwin/resources/macFUSE.pkg
          hdiutil detach /tmp/macfuse-mount
          rm /tmp/macfuse.dmg

      # Setup keychain and import certificates for macOS signing
      - name: Setup Keychain and Import Certificates
        if: runner.os == 'macOS' && inputs.push_artifacts == true
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          MACOS_INSTALLER_CERTIFICATE: ${{ secrets.MACOS_INSTALLER_CERTIFICATE }}
          MACOS_INSTALLER_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_INSTALLER_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD="actions"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security default-keychain -s "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_NAME"

          # Import Application certificate
          echo "$MACOS_CERTIFICATE" | base64 --decode > /tmp/app_cert.p12
          security import /tmp/app_cert.p12 -k "$KEYCHAIN_NAME" -P "$MACOS_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/productsign -T /usr/bin/security
          rm /tmp/app_cert.p12

          # Import Installer certificate (if available)
          if [ -n "$MACOS_INSTALLER_CERTIFICATE" ]; then
            echo "$MACOS_INSTALLER_CERTIFICATE" | base64 --decode > /tmp/installer_cert.p12
            security import /tmp/installer_cert.p12 -k "$KEYCHAIN_NAME" -P "$MACOS_INSTALLER_CERTIFICATE_PASSWORD" \
              -T /usr/bin/codesign -T /usr/bin/productsign -T /usr/bin/security
            rm /tmp/installer_cert.p12
          fi

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | tr -d '"')

      # Sign, create DMG/PKG, and notarize macOS app
      - name: Sign and package macOS app
        if: runner.os == 'macOS' && inputs.push_artifacts == true
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VERSION: ${{ inputs.version }}
        run: |
          CERT_IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | grep -o '"[^"]*"' | tr -d '"')

          # Sign app
          codesign --sign "$CERT_IDENTITY" --force --options runtime --timestamp --verbose bin/arco.app
          codesign --verify --strict bin/arco.app

          # Create and sign DMG
          create-dmg --volname "Arco" --volicon "build/darwin/icons.icns" \
            --window-pos 200 120 --window-size 600 400 --icon-size 100 \
            --icon "arco.app" 175 190 --hide-extension "arco.app" --app-drop-link 425 190 \
            --no-internet-enable "bin/Arco.dmg" "bin/arco.app"
          codesign --sign "$CERT_IDENTITY" --timestamp bin/Arco.dmg

          # Notarize DMG
          xcrun notarytool submit bin/Arco.dmg --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID" --wait
          xcrun stapler staple bin/Arco.dmg

          # Create PKG
          chmod +x build/darwin/scripts/postinstall
          pkgbuild --identifier com.arcobackup.arco --version "${VERSION#v}" \
            --install-location "Applications" --scripts build/darwin/scripts \
            --component bin/arco.app /tmp/arco-component.pkg
          productbuild --distribution build/darwin/distribution.xml \
            --package-path /tmp bin/Arco-Installer.pkg
          rm /tmp/arco-component.pkg

          # Sign PKG (if installer cert available)
          INSTALLER_IDENTITY=$(security find-identity -v | grep "Developer ID Installer" | head -1 | grep -o '"[^"]*"' | tr -d '"')
          if [ -n "$INSTALLER_IDENTITY" ]; then
            productsign --sign "$INSTALLER_IDENTITY" bin/Arco-Installer.pkg bin/Arco-Installer-signed.pkg
            mv bin/Arco-Installer-signed.pkg bin/Arco-Installer.pkg
          fi

          # Notarize PKG
          xcrun notarytool submit bin/Arco-Installer.pkg --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" --team-id "$APPLE_TEAM_ID" --wait
          xcrun stapler staple bin/Arco-Installer.pkg

      # Compress build artifact (Linux)
      - name: Compress build artifact (Linux)
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'Linux'
        id: compress
        run: |
          cd ./bin
          ZIP_NAME="${{ matrix.build.zip-name }}.zip"
          zip -j "../$ZIP_NAME" arco
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

      # Upload build assets
      - name: Upload build artifacts (Linux)
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.compress.outputs.zip_name }}
          path: ${{ steps.compress.outputs.zip_name }}
          retention-days: 30

      - name: Upload build artifacts (macOS)
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: arco-macos
          path: |
            bin/Arco.dmg
            bin/Arco-Installer.pkg
          retention-days: 30

      # Upload to release if this is a release build
      - name: Upload to release (Linux)
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'Linux' && inputs.push_artifacts && inputs.version != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.version }}
          files: ${{ steps.compress.outputs.zip_name }}
          draft: false
          prerelease: false

      - name: Upload to release (macOS)
        if: steps.should-build.outputs.should_run == 'true' && runner.os == 'macOS' && inputs.push_artifacts && inputs.version != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.version }}
          files: |
            bin/Arco.dmg
            bin/Arco-Installer.pkg
          draft: false
          prerelease: false
